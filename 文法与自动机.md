
# 语言和文法

## 引言
**自然语言**，如英语，法语，德语或西班牙语，都极为复杂。事实上，对于一种自然语言，看起来不太可能说出它的所有语法规则。将一种语言自动翻译成另一种语言的研究引出了 **形式语言** 的概念。

与自然语言不同，形式语言是由一组意义明确的语法规则定义的，语法规则不仅对于语言学和自然语言的研究十分重要，而且对于程序设计语言的研究也很重要。

## 短语结构文法

### 定义 20.2.1 字母表和语言
一个 **字母表** $\Sigma$ 是一个非空有限的集合，这个集合中的元素称为 **符号**。由 $\Sigma$ 中的符号组成的有限长度的字符串称为 $\Sigma$ 上的 **词**。不包含任何符号的字符串称为 **空串**，记为 $\lambda$。$\Sigma$ 上所有词的集合记为 $\Sigma^*$，$\Sigma^*$ 的任何子集称为 $\Sigma$ 上的一个 **语言**。


### 定义 20.2.2 短语结构文法
一个 **短语结构文法** 是一个四元组 $G = (\Sigma, T, S, P)$，其中 $\Sigma$ 是一个字母表，$T \subseteq \Sigma$ 是所有的终结符集，$S \in \Sigma - T$ 是起始符，$P$ 是产生式集合。集合 $\Sigma - T$ 记为 $N$，$N$ 中的元素称为 **非终结符**。$P$ 中的每个产生式的左端必须至少包含一个非终结符。


### 例 20.2.1
设 $G = (\Sigma, T, S, P)$，其中 $\Sigma = \{a, b, A, B, S\}$，$T = \{a, b\}$，$S$ 是起始符，$P = \{S \rightarrow ABa, A \rightarrow BB, B \rightarrow ab, AB \rightarrow b\}$，则 $G$ 是一个短语结构文法。


## 派生

### 定义 20.2.3
设 $G = (\Sigma, T, S, P)$ 是一个短语结构文法，$w_0 = lz_0r$（即 $l,z_0$ 和 $r$ 的连接）和 $w_1 = l z_1 r$ 是 $\Sigma$ 上的字符串。若 $z_0 \rightarrow z_1$ 是 $G$ 的一个产生式，则称由 $w_0$ **可直接派生** $w_1$，记为 $w_0 \Rightarrow w_1$。如果 $\Sigma$ 上的字符串 $w_0, w_1, \dots, w_n, n \geq 0$，满足 $w_0 \Rightarrow w_1, w_1 \Rightarrow w_2, \dots, w_{n - 1} \Rightarrow w_n$，那么称由 $w_0$ **可派生** $w_n$，记为 $w_0 \stackrel{\ast}{\Rightarrow} w_n$。由 $w_0$ 得到 $w_n$ 的序列称为 **派生**。


## 生成的语言
### 定义 20.2.4
设 $G =(\Sigma, T, S, P)$ 是一个短语结构文法，由 $G$ **生成的语言**（或 $G$ 的语言）是起始符 $S$ 能够派生的所有终结符构成的集合，记为 $L(G)$，即 $$L(G) = \{w \in T^* | S \stackrel{\ast}{\Rightarrow} w\}$$

## 文法类型

- **0 型文法** 对其产生式没有限制。
- **1 型文法** 只有两种形式的产生式，一种是 $w_1 \rightarrow w_2$ 形式的产生式，其中 $w_1 = lAr$，$w_2 = lwr$，$A$ 是一个非终结符，$l$ 和 $r$ 是 $0$ 个或多个终结符或非终结符构成的串，$w$ 是终结符或非终结符构成的非空串。它还可以有产生式 $S \rightarrow \lambda$，但 $S$ 不能出现在任何其他产生式的右边。
- **2 型文法** 只有形如 $w_1 \rightarrow w_2$ 的产生式，其中 $w_1$ 是一个单个的非终结符的符号。
- **3 型文法** 只有形如 $w_1 \rightarrow w_2$ 的产生式，同时满足 $w_1 = A$ 且 $w_2 = aB$ 或 $w_2 = a$ 或 $w_2 = \lambda$，其中 $A$ 和 $B$ 是非终结符，$a$ 是终结符。

2 型文法又称为 **上下文无关文法**，因为出现在一个产生式左端的非终结符可以被一个字符串替换，而不管此字符串中的符号是什么。 2 型文法生成的语言称为 **上下文无关语言**。当一个文法具有形如 $lw_1r \rightarrow lw_2 r$（而不是形如 $w_1 \rightarrow w_2$）的产生式时，这样的文法称为 1 型文法或 **上下文有关文法**，因为只有当 $w_1$ 被字符串 $l$ 和 $r$ 包围时，才能替换为 $w_2$。1 型文法生成的语言称为 **上下文有关语言**。3 型文法又称为 **正则文法**。正则文法生成的语言称为 **正则语言**。

> 上下文有关文法的定义最复杂。
> 
> $\{0^m1^n \space | \space m, n \in \mathbb{N}\}$ 是正则语言。
> $\{0^n1^n \space | \space n \in \mathbb{N}\}$ 是上下文无关语言，因为这个文法的产生式为 $S\rightarrow 0S1$  和 $S \rightarrow \lambda$。
> $\{0^n1^n2^n \space | \space n \in \mathbb{N}\}$ 是上下文有关语言，但不是 2 型语言。

![[Pasted image 20251219113310.png]]


### Chomsky 层次结构

- **0 型 (短语结构文法)**：无特殊限制。

- **1 型 (上下文有关文法)**：左侧长度 $\le$ 右侧长度（除 $S \rightarrow \lambda$ 外）。

- **2 型 (上下文无关文法)**：左侧必须是单个变元。

- **3 型 (正则文法)**：左侧单个变元，右侧为 $a$ 或 $aB$。

### 判定技巧总结

1. **看左边**：如果有终结符（如 $aA \rightarrow \dots$），则必不是 2 型或 3 型。

2. **看长度**：如果左边字符数多于右边（如 $AB \rightarrow a$），则必不是 1 型。

3. **看空串**：若存在 $A \rightarrow \lambda$ 且 $A$ 不是开始符号，通常会导致文法降级为 0 型。


## 派生树
对上下文无关语法生成的语言，其派生可以用有序树表示成图形，这样的树称为 **派生树** 或 **语法分析树**。树根表示起始符， 树的内部结点表示在派生过程中产生的非终结符，树的叶结点表示终结符。


## 巴科斯-诺尔范式（BNF）

在巴科斯-诺尔范式中，将左端是同一个非终结符的所有产生式合并成一个式子，而不是将这些产生式都列出来。我们采用符号 `::=` 代替 $\rightarrow$，将非终结符用 $\langle\rangle$ 括起来，并在一个式子里列出所有这些产生式的右端，用竖线将这些产生式分开。例如，产生式 $A\rightarrow Aa, A\rightarrow a, A\rightarrow AB$ 可以合并成 $\langle A\rangle::=\langle A\rangle a|a|\langle A\rangle\langle B\rangle$。


---

# 带输出的有限状态自动机

### 定义 21.2.1

一个有限状态机 $M=(S,I,O,f,g,s_{0})$ 由如下部分组成：

（1）$S$ 是一个有限的状态集；
（2）$I$ 是一个有限的输入字母表；
（3）$O$ 是一个有限的输出字母表；
（4）$f:S\times I\rightarrow S$ 是一个转移函数，$f$ 为每个状态和输入对指派一个新状态；
（5）$g:S\times I\rightarrow O$ 是一个输出函数，$g$ 为每个状态和输入对指派一个输出；
（6）$s_{0}\in S$ 是一个初始状态。



设 $M = (S, I, O, f, g, s_0)$ 是一个有限状态机，可以用 **状态表** 来表示状态函数 $f$ 和输出函数 $g$ 的值。
如：自动售货机的状态表：
![[Pasted image 20251219120503.png]]
![[Pasted image 20251219120512.png]]

表示有限状态机的另一种方法是 **状态图**，这是一个边带有标号的有向图。在这个图中，状态由圈表示，转移由带输入和输出对标号的箭头表示。

自动售货机的状态图：

![[Pasted image 20251219120521.png]]


### 输出函数的扩展

设输入字符串为 $x=x_{1}x_{2}\cdots x_{k}$。读这个输入使得机器从状态 $s_{0}$ 变为状态 $s_{1}$，其中 $s_{1}=f(s_{0},x_{1})$，然后变为状态 $s_{2}$，其中 $s_{2}=f(s_{1},x_{2})$，以此类推，对于 $j=1,2,\cdots,k$，$s_{j}=f(s_{j-1},x_{j})$，最后，以状态 $s_{k}=f(s_{k-1},x_{k})$ 结束。这个转移序列就产生了输出字符串 $y=y_{1}y_{2}\cdots y_{k}$，其中 $y_{1}=g(s_{0},x_{1})$ 是对应于从 $s_{0}$ 到 $s_{1}$ 转移的输出，$y_{2}=g(s_{1},x_{2})$ 是对应于从 $s_{1}$ 到 $s_{2}$ 转移的输出，等等。
一般地，$y_{j}=g(s_{j-1},x_{j})$，$j=1,2,\cdots,k$。这样，我们可以将输出函数 $g$ 的定义扩展到输入字符串，即定义 $g(x)=y$，其中 $y$ 是对应于输入字符串 $x$ 的输出。


## 有限状态机的应用

### 例 21.2.5
**单位延迟机** 是许多电子装置中的一个重要部件，它将输入字符延迟一定的时间量后输出。怎么构造一个有限状态机使其将输入字符串延迟一个单位的时间呢？即，对于输入的比特串 $x_1x_2 \dots x_k$，怎么才能输出比特串 $0x_1x_2 \dots x_{k - 1}$ ?

> **解：** 可以如下构造一个延迟机：它有两种可能的输入，即 $0$ 和 $1$；它还必须有一个初始状态 $s_{0}$。因为它还要记住前一个输入是 $0$ 还是 $1$，所以它还需要另外两个状态 $s_{1}$ 和 $s_{2}$，使得若前一个输入是 $1$，则机器处于状态 $s_{1}$；若前一个输入是 $0$，则机器处于状态 $s_{2}$。从 $s_{0}$ 出发的第一个转移产生输出 $0$，从 $s_{1}$ 出发的每个转移都产生输出 $1$，从 $s_{2}$ 出发的每个转移都产生输出 $0$。故对应于输入字符串 $x_{1}x_{2}\cdots x_{k}$ 的输出是这样的一个字符串：从 $0$ 开始，后面跟 $x_{1}$，再跟 $x_{2}$，$\cdots$，最后以 $x_{k-1}$ 结束。这个机器的状态图如下。

![[Pasted image 20251219121952.png]]


### 例 21.2.6
试构造一个有限状态机，使其利用正整数的二进制展开式将两个正整数相加。

![[Pasted image 20251219130700.png]]

$s_0$ 不进位，$s_1$ 进位。


### 例 21.2.7
在某种编码方法中，当一个信息中出现了三个连续的 1 时，信息接收器就知道已经发生了一个传送错位。试构造一个有限状态机，使得它输出 1 当且仅当它所接受的最后三位都是 1。

![[Pasted image 20251219131129.png]]

有限状态机的最终输出都是 1，当且仅当输入字符串以 111 作为结束。因此，我们说有限状态机能够识别以 111 作为结束的字符串。这就引出了下面的定义。


### 定义 21.2.2 接受语言
令 $M=(S,I,O,f,g,s_{0})$ 是一个有限状态机，并且 $L\subseteq I^{*}$，那么当输入串 $x\in L$，并且当且仅当 $x$ 作为 $M$ 的输入，$M$ 的最后一个输出位是 $1$ 时，我们说有限状态机 $M$ 能够 **识别**（或**接受**）$L$。


---

# 不带输出的有限状态机

有限状态机的最重要应用之一是语言识别。之前我们说明了可以用带输出的有限状态机来识别语言，此外，还有一些其他类型的有限状态机，它们是为识别语言而专门设计的。这些机器不产生输出，但有终结状态。一个串能被它识别当且仅当它把初始状态转变为某个终结状态。

## 串的集合

### 定义 22.1.1
设 $\Sigma$ 是一个字母表，$A, B \subseteq \Sigma^*$。$A$ 和 $B$ 的 **连接** 是所有形如 $xy$ 的串构成的集合，记为 $AB$，其中 $x \in A, y \in B$。

> $AB = BA$ 不一定成立。
> 由两个串集合的连接的定义还可以定义 $A^n$，$n \in \mathbb{N}$，其递归定义如下 $$A^0 = \{\lambda\},\qquad A^{n + 1} = A^n A, \space n \in \mathbb{N}$$


### 定义 22.1.2 克林闭包（Kleene closure）
设 $A \subseteq \Sigma^*$，$A$ 的 **克林闭包（Kleene closure)** 是 $A$ 中任意多个串的连接组成的集合，记为 $A^*$，即 $A^* = \bigcup\limits_{k = 1}^{\infty} A^k$


## 有限状态自动机

### 定义 22.2.1
一个 **有限状态自动机** $M = (S, I, f, s_0, F)$ 由下列五部分组成：

(1) $S$ 是一个有限的状态集；
(2) $I$ 是一个有限的输入字母表；
(3) $f:S \times I \rightarrow S$ 是一个状态转移函数，$f$ 为每个状态和输入对指派下一个状态；
(4) $s_0 \in S$ 是一个初始状态；
(5) $F \subseteq S$ 是一个终结状态（或可接受状态）集。

有限状态自动机也可以用状态表或状态图来表示。在状态图中，终结状态用双圈表示。

![[Pasted image 20251219132538.png]]


### 转移函数的扩展
有限状态自动机 $M=(S,I,f,s_{0},F)$ 的转移函数可以进行扩展，使其对所有状态与串的对都有值，也就是说，$f$ 可以被扩展成这样一个函数 $f:S\times I^{*}\rightarrow S$。设 $x=x_{1}x_{2}\cdots x_{k}$ 是 $I^{*}$ 中的一个串，则状态 $f(s_{1},x)$ 是这样得到的：从状态 $s_{1}$ 开始，从左到右连续地输入 $x$ 中的每个符号。从 $s_{1}$ 进入状态 $s_{2}=f(s_{1},x_{1})$，然后进入状态 $s_{3}=f(s_{2},x_{2})$，以此类推，直到 $f(s_{1},x)=f(s_{k},x_{k})$。

形式上，可以通过如下公式递归地为确定性的有限状态机 $M=(S,I,f,s_{0},F)$ 定义其扩展状态转移函数 $f$：

（1）对于状态集 $S$ 中的每个状态 $s$，都有 $f(s,\lambda)=s$；
（2）对于所有的 $s\in S,x\in I^{*},a\in I$，有 $f(s,xa)=f(f(s,x),a)$。

可以使用结构化归纳和递归定义来证明扩展转移函数的这个性质。例如，可证明对于状态集 $S$ 中的每个状态 $s$ 和 $I^{*}$ 中的字符串 $x,y$，均有 $f(s,xy)=f(f(s,x),y)$。


## 有限状态机的语言识别

### 定义 22.3.1
若串 $x$ 将机器 $M=(S,I,f,s_{0},F)$ 从初始状态变为一个终结状态，即 $f(s_{0},x)$ 是 $F$ 中的一个状态，则称串 $x$ 可被机器 $M$ **识别** 或 **接受**。机器 $M$ 识别（或接受）的 **语言** 是 $M$ 识别的所有串的集合，记为 $L(M)$。若两个有限状态自动机识别相同的语言，则称它们是 **等价** 的。

![[Pasted image 20251219133020.png]]



## 非确定性的有限状态自动机

前面讨论的有限状态自动机都是 **确定性的有限状态自动机** ，因为对每对状态和输入值，转移函数只给出唯一的下一个状态。还有一种有限状态自动机，它对每对输入值和状态，有多个可能的下一个状态，这样的机器称为 **非确定性的**。

### 定义 22.4.1
一个非确定性的有限状态自动机 $M=(S,I,f,s_{0},F)$ 由下列五部分组成：

（1）$S$ 是一个有限的状态集；
（2）$I$ 是一个有限的输入字母表；
（3）$f:S\times I\rightarrow P(S)$ 是一个转移函数，为每个状态和输入对指派一个状态集；
（4）$s_{0}\in S$ 是一个初始状态；
（5）$F\subseteq S$ 是一个终结状态（或可接受状态）集。

非确定性的有限状态自动机也可以用状态表和状态图来表示。在状态表中，对每对状态和输入值，列出所有可能的下一个状态。在状态图中，从一个状态到每个可能的下一个状态，都画一条边，这条边的标号是导致这个转移的一个或多个输入。

![[Pasted image 20251219134044.png]]

![[Pasted image 20251219134059.png]]

非确定性的有限状态自动机如何识别串 $x=x_{1}x_{2}\cdots x_{k}$？第一个输入符号 $x_{1}$ 将初始状态 $s_{0}$ 变为状态集 $S_{1}$。下一个输入符号 $x_{2}$ 将 $S_{1}$ 中的每个状态都变为一个状态集。设 $S_{2}$ 是这些集合的并集。将这个过程继续下去，在每个步骤中，使用上一个步骤产生的每个状态和当前的输入符号，获得其产生所有状态。使用 $x$ 从 $s_{0}$ 所能得到的状态中，如果有一个终结状态，我们就说识别或接受串 $x$。一个非确定性的有限状态自动机所识别的语言是这个自动机所识别的所有串的集合。

一个重要的事实是，非确定性的有限状态自动机所能识别的语言也能被确定性的有限状态自动机所识别。


### 定义 22.4.1

如果语言 $L$ 可以由非确定性的有限状态自动机 $M_0$ 所识别，那么 $L$ 也可以由一个确定性的有限状态自动机 $M_1$ 来识别。

![[Pasted image 20251219134816.png]]

---
# 语言的识别

## 引言
有限状态自动机可以用作语言识别器，那么这些机器能识别什么样的集合呢？
这个问题虽然看起来极为困难，但能被有限状态自动机所识别的语言有一个简单特征。
克林（Stephen Kleene）于 1956 年证明了一个集合能够被一个有限状态自动机识别当且仅当这个集合是以任意顺序通过对空集、空串和单字符串的连接、并或克林闭包构造出来。以这种方法构造出来的集合称为 **正则集合**。

### 定义 23.1.1 正则表达式
集合 $I$ 上的 **正则表达式** 的递归定义为：

1. 符号 $\emptyset$ 是一个正则表达式；
2. 符号 $\lambda$ 是一个正则表达式；
3. 若 $x \in I$，则符号 $x$ 是一个正则表达式；
4. 当 $A, B$ 是正则表达式时，符号 $(AB),(A \cup B),A^*$ 都是正则表达式。

每个正则表达式都表示一个由下列规则定义的集合：

1. $\emptyset$ 表示空集，即没有字符串的集合；
2. $\lambda$ 表示集合 $\{\lambda\}$，即空串组成的集合；
3. $x$ 表示集合 $\{x\}$，它只包含单个符号 $x$ 组成的字符串；
4. $(AB)$ 表示 $A$ 和 $B$ 代表的集合的连接；
5. $(A \cup B)$ 表示 $A$ 和 $B$ 代表的集合的并；
6. $A^*$ 表示 $A$ 代表的集合的克林闭包。

正则表达式表示的集合称为 **正则集合**。
正则集合可由正则表达式来描述，所以，当我们提到正则表达式 $A$ 时，指的是此正则表达式 $A$ 表示的集合。
在不必要时，我们将去掉正则表达式外面的括号。


### 例 23.1.1
正则表达式 $10^*, (10)^*, 0 \cup 01, 0(0 \cup 1)^*$ 和 $(0^*1)^*$ 所规定的正则集合中有哪些字符串？

![[Pasted image 20251219140059.png]]



### 例 23.1.2
找到表示下列集合的正则表达式。

1. 长度为偶数的比特串构成的集合。
2. 以 0 作为结束并且不包含 11 的比特串构成的集合。
3. 包含奇数个 0 的比特串构成的集合。

> 1. $(00 \cup 01 \cup 10 \cup 11)^*$
> 2. $(0 \cup 10)^*(0 \cup 10)$ ，注意，$(0 \cup 10)^*$ 包含空串
> 3. $1^*01^*(01^*01^*)^*$



## 克林定理

### 定理 23.2.1 克林定理
一个集合是正则的，当且仅当它可由一个有限状态自动机识别。

> 证明：[[PKU离散数学基础slides.pdf#page=1513&selection=97,1,99,1|PKU离散数学基础slides, 页面 1,513]]

**构造过程：**
$AB$ :
1. $A$ 的初始状态是 $AB$ 的初始状态。
2. $A$ 的终结状态不再是 $AB$ 的终结状态。
3. 对每个指向原来 $A$ 的终结状态 $a_n$ 的转移 $f(a_{n -1}, i) = a_n$，添加从 $a_{n - 1}$ 到 $s_B$ 的转移 $f(a_{n - 1}, i) = s_B$ （$a_{n - 1}$ 可能有多个，甚至可能包括 $a_n$ 本身）
4. 若 $A$ 中包含空串 $\lambda$，例如 $A$ 是克林闭包，添加从 $s_A$（也是新的初始状态 $s_{AB}$）到 $s_B$ 的所有转移 $f(s_B,i) = s_{B_i}$ 的转移 $f(s_A, i) = s_{B_i}$
![[Pasted image 20251219171946.png]]

$A + B(A \cup B)$ :
1. 构造新的状态 $S_{A \cup B}$ 作为 $A + B$ 的初始状态
2. 对 $A,B$ 的初始状态的所有转移 $f(s_A,i) = s_{A_i},f(s_B, i) = s_{B_i}$ 添加新的转移 $f(s_{AB}, i) = s_{A_i}, f(s_{AB}, i) = s_{B_i}$
![[Pasted image 20251219172014.png]]

$A^*$ :
1. 构造新的初始状态 $s_{A^*}$，它也是新的终结状态（为了处理空串 $\lambda$）
2. 对原来初始状态 $s_A$ 的所有转移 $f(s_A, i) = s_{A_i}$，所有 $A^*$ 的终结状态 $s_*$（包括 $s_{A^*}$ ）添加指向 $s_{A_i}$ 的转移 $f(s_{*}, i) = s_{A_i}$
![[Pasted image 20251219172051.png]]



### 例 23.2.1
构造一个非确定性的有限状态自动机来识别正则集合 $1^* \cup 01$

![[Pasted image 20251219141700.png]]

![[Pasted image 20251219142022.png]]
![[Pasted image 20251219142032.png]]


## 正则集合和正则文法

3 型文法（正则文法）：这是一个形如 $G = (\Sigma, T, S, P)$ 的文法，文法的每个产生式的形式是 $S \rightarrow \lambda, A \rightarrow a$ 或 $A \rightarrow aB$，其中 $a$ 是终结符，$A$ 和 $B$ 是非终结符。正则文法和正则集合之间具有紧密的联系。

### 定理 23.3.1
一个集合可以由正则文法生成，当且仅当它是一个正则集合。


### 例 23.3.2
求一个正则文法，使之生成的集合是图 23.3.2 表示的有限状态自动机所识别的正则集合。

![[Pasted image 20251219142842.png]]

> **解：** 生成该自动机所识别集合的文法为 $G = (\Sigma, T, S, P)$，其中 $\Sigma = \{S,A,B, 0, 1\}$，其符号 $S, A, B$ 分别对应于状态 $s_0, s_1$ 和 $s_2$，$T = \{0,1\}$，$S$ 是起始符，产生式为 $S \rightarrow 0A, S \rightarrow 1B, S \rightarrow 1, S \rightarrow \lambda, A \rightarrow 0A, A \rightarrow 1B, A \rightarrow 1, B \rightarrow 0A, B \rightarrow 1B, B \rightarrow 1$

> ***methods:***
> 1. 给每个状态标号（$S, A, B, \dots$)，初始状态 $s_0$ 对应 $S$
> 2. 对每个状态转移函数 $f(s_i, j) = s_k$ （就是每个状态图上的箭头），设 $s_i,s_k$ 对应 $S_i, S_k$
> 	1. $P$ 中加上 $S_i \rightarrow jS_k$
> 	2. 若 $s_k$ 是终结状态，$P$ 中加上 $S_i \rightarrow j$
> 3. 若 $s_0$ 是终结状态，$P$ 中加上 $S \rightarrow \lambda$




### 例 23.3.3 一个不能由有限状态自动机识别的集合
证明集合 $\{0^n1^n \space | \space n \in \mathbb{N}\}$ 不是正则的。


### 泵引理

**泵引理（Pumping Lemma）** 是形式语言理论中非常重要的一个工具。如果说“林克定理”（Thompson 构造法）是用来 **构建** 自动机的，那么泵引理通常是用来**拆台**的——它的主要用途是**证明某个语言不是正则语言**（或不是上下文无关语言）。

简单来说，泵引理告诉我们：如果一个语言是正则的，那么只要字符串足够长，它内部就一定有一段可以像“抽水泵”一样无限重复，而产生的字符串依然属于这个语言。

---

### 1. 直观理解：为什么会有“泵”？

想象一个**有限状态自动机（DFA）**，它只有固定数量（假设为 $p$ 个）的状态。

- 如果你输入一个非常长的字符串（长度大于 $p$），根据**抽屉原理（鸽巢原理）**，自动机在处理这个字符串时，必然会经过同一个状态两次。
    
- 一旦两次经过同一个状态，就意味着路径中出现了一个**环（Loop）**。
    
- 既然有环，你就可以在这个环上绕 0 圈、1 圈、甚至无数圈。
    

---

### 2. 正则语言泵引理的正式定义

如果语言 $L$ 是正则的，那么存在一个常数 $p$（称为泵长），使得对于 $L$ 中任何长度不小于 $p$ 的字符串 $s$，都可以将其拆分为三部分 $s = xyz$，并满足以下三个条件：

1. **$|y| \geq 1$**：被泵的部分 $y$ 不能为空（环里至少得有一个字符）。

2. **$|xy| \leq p$**：前两部分的长度加起来不能超过泵长。

3. **对所有 $i \geq 0$，字符串 $xy^iz \in L$**：无论你把中间的 $y$ 重复多少次（包括 0 次，即删除 $y$），得到的字符串依然在语言 $L$ 中。


---

### 3. 如何用泵引理进行“反证法”？

这是考试中最常见的用法。要证明一个语言 $L$ **不是**正则的，我们通常走这四步：

1. **假设** $L$ 是正则的。

2. 那么它必然存在一个泵长 $p$。

3. **找茬**：挑出一个聪明的字符串 $s \in L$，且它的长度 $|s| \geq p$。

4. **推翻**：证明无论别人怎么拆分 $s = xyz$（只要满足前两个条件），你只要“泵”一下（比如取 $i=2$ 或 $i=0$），生成的字符串 $xy^iz$ 必然**不在** $L$ 中。


**结论**：假设不成立，$L$ 不是正则语言。

---

### 4. 经典案例：证明 $L = \{0^n 1^n \mid n \geq 0\}$ 不是正则语言

这个语言要求 $0$ 的个数和 $1$ 的个数严格相等。

- **挑字符串**：我们选 $s = 0^p 1^p$。显然它的长度 $2p \geq p$。

- **拆分**：根据条件 $|xy| \leq p$，那么 $xy$ 这一段必然全都是字符 $0$。因此，被泵的部分 $y$ 也必然全都是 $0$。

- **泵一下**：我们让 $i=2$，即查看 $xy^2z$。
    
    - 原来的字符串是：$p$ 个 $0$ 和 $p$ 个 $1$。
        
    - 现在的字符串是：增加了 $y$ 长度的 $0$，但 $1$ 的数量没变。
        
- **打脸**：现在的 $0$ 比 $1$ 多了！这个字符串不再属于 $L$。
    
- **结果**：$L = \{0^n 1^n\}$ 不是正则语言（因为它需要“无限的记忆”来数数，而有限自动机办不到）。
    

---

### 5. 补充：上下文无关语言的泵引理

针对你之前问到的 **2 型文法（上下文无关文法）**，也有对应的泵引理。它的拆分更复杂一些，把字符串拆成五部分：$s = uvwxy$。

- 它泵的是两个部分 $v$ 和 $x$：$uv^iwx^iy \in L$。
    
- 这通常用来证明像 $L = \{a^n b^n c^n\}$ 这样的语言不是上下文无关的。
    

---

### 总结对照

|**工具**|**目标**|**核心逻辑**|
|---|---|---|
|**林克定理/Thompson构造**|**正向**：从正则表达式得到 NFA|用 $\epsilon$ 弧拼接基本单元|
|**泵引理**|**反向**：证明语言不是正则/上下文无关|利用抽屉原理寻找无法重复的“环”|

---

# 图灵机

