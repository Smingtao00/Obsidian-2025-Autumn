## 冒泡排序(Bubble sort)

#冒泡排序

**原理**：重复遍历要排序的数列，比较相邻元素，如果顺序错误就交换它们。

**稳定**：相邻元素相等时不会交换

**时间复杂度**：

- 最好情况：$O(n)$ - 数组已排序
- 平均情况：$O(n²)$
- 最坏情况：$O(n²)$

**空间复杂度**：$O(1)$

**C++实现**

```c++ {.line-numbers}
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; i < n - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        if (!swapped) break;
    }
}
```

### Python实现

```python {.line-numbers}
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr
```



---

##  选择排序(Selection Sort)

#选择排序

**原理**：每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。

**不稳定**：选择最小元素并与当前元素交换时可能会改变元素的相对位置

**时间复杂度**：$O(n^2)$
**空间复杂度**：$O(1)$

**C++实现**

```c++ {.line-numbers}
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}
```

### Python实现

```python {.line-numbers}
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr
```



---

## 插入排序(Insertion Sort)

#插入排序

**原理**：将未排序元素逐个插入到已排序部分的正确位置。

**稳定**：从后向前比较，相等元素不会移动

**时间复杂度**：

- 最好情况：$O(n)$ - 数组已排序
- 平均情况：$O(n^2)$
- 最坏情况：$O(n^2)$

**空间复杂度**：$O(1)$

**C++实现**

```c++ {.line-numbers}
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

### Python实现

```python {.line-numbers}
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```



---

## 希尔排序(Shell Sort)

#希尔排序

**原理**：插入排序的改进版，通过比较相距一定间隔的元素来工作，逐步减少间隔。

**时间复杂度分析**：

- 最好情况：$O(n log n)$ - 使用好的间隔序列
- 平均情况：取决于间隔序列，一般为$O(n^{1.5})$
- 最坏情况：$O(n^2)$ - 使用较差的间隔序列

**空间复杂度**：$O(1)$ - 原地排序

**稳定性**：不稳定 - 相同元素可能被分到不同的组中

**C++实现**

```c++ {.line-numbers}
void shellSort(vector<int>& arr) {
    int n = arr.size();
    // 使用Knuth序列：1, 4, 13, 40, 121, ...
    int gap = 1;
    while(gap < n / 3) {
        gap = gap * 3 + 1;
    }
    
    while(gap > 0) {
        for(int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            for(j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
        gap /= 3;
    }
}
```

**Python实现**

```python {.line-numbers} 
def shell_sort(arr):
    n = len(arr)
    gap = 1
    while gap < n // 3：
    	gap = gap * 3 + 1
    
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 3
    return arr
```



---

## 归并排序(Merge Sort) 

#归并排序

**原理**：分治法，将数组分成两半，分别排序，然后合并。

**时间复杂度分析**：

- 最好情况：$O(n log n)$
- 平均情况：$O(n log n)$
- 最坏情况：$O(n log n)$

**空间复杂度**：$O(n)$ - 需要额外的数组来合并

**稳定性**：稳定 - 合并时遇到相等元素优先取左边的

**C++实现**

```c++ {.line-numbers}
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    vector<int> L(n1), L(n2);
    for(int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for(int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    
    int i = 0, j = 0, k = left;
    
    while(i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++；
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    while(i < n1) {
        arr[k++] = L[i++];
    }
    while(j < n2) {
        arr[k++] = R[j++];
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

```

注意边界条件！

**Python实现**

```python {.lint-numbers}
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        
        merge_sort(left)
        merge_sort(right)
        
        i = j = k = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1
            
        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1
        
        while j < len(right):
            arr[k] = right[j]
            j += 1
            k += 1
    
    return arr
```



---

## 快速排序(Quick Sort)

#快速排序

**原理**：分治法，选择一个基准元素，将数组分成两部分，一部分小于基准，一部分大于基准。

**时间复杂度分析**：

- 最好情况：$O(n log n)$ - 每次划分都很平衡
- 平均情况：$O(n log n)$
- 最坏情况：$O(n^2)$ - 每次划分都极度不平衡

**空间复杂度**：$O(log n)$ - 递归调用栈的空间

**稳定性**：不稳定 - 分区过程中可能改变相等元素的相对顺序

**C++实现**

```c++ {.line-numbers}
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for(int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

**Python实现**

```python {.line-numbers}
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)
```



---

## 堆排序(Heap Sort)

#堆排序

**原理**：利用堆这种数据结构进行排序，构建最大堆，然后逐个取出堆顶元素。

**时间复杂度分析**：

- 最好情况：$O(n log n)$
- 平均情况：$O(n log n)$
- 最坏情况：$O(n log n)$

**空间复杂度**：$O(1)$ - 原地排序

**稳定性**：不稳定 - 堆调整过程中可能改变相等元素的相对顺序

**C++实现**

```c++ {.line-numbers}
void heapify(vector<int>& arr, int n, int i) {
	while(i * 2 + 1 < n) {
        int child = i * 2 + 1;
        if (child + 1 < n && arr[child] < arr[child + 1]) child = child + 1;
		if (arr[i] >= arr[child]) return;
        swap(arr[i], arr[child]);
        i = child;
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    //构建大根堆
    for (int i = n - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    //一个个从堆顶取出元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapity(arr, i, 0);
    }
}
```

**Python实现 **

```python {.line-numbers}
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 一个个从堆顶取出元素
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    
    return arr
```


---

## 桶排序

注意

