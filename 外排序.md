
**核心思想：** 尽量减少访问外存次数。

- 据内存的大小，将外存中的数据文件划分成若干段，每次把其中一段读入内存并用内排序方法进行排序。 
- 这些已排序的段或子文件称为 **顺串** 或 **归并段**。
- 顺串写回外存等待进一步处理，让出内存空间处理文件的其它未排序的段。

---
## 基本过程

1. 置换选择排序

> 目的：把外存文件初始化为尽可能长的有序顺串集合；

2. 归并排序

> 目的：把顺串集合逐趟归并排序，形成全局有序的外存文件。

---
## 时间组成

1. 产生初始顺串的内排序所需时间。
2. 初始化顺串和归并过程所需的读写（I/O）时间。
3. 内部归并所需要的时间。

> 减少外存信息的读写（I/O）次数是提高外部排序效率的关键。

---
## 置换选择排序

输入文件 $\rightarrow$ 输入缓冲区 $\rightarrow$ RAM $\rightarrow$ 输出缓冲区 $\rightarrow$ 输出顺串文件

- 目的：将文件生成若干初始顺串（顺串越长越好，个数越少越好）
- 实现：借助在 RAM 中的堆来完成

**思路**
- 首先传入 $m$ 个元素进内存建堆，设置堆尾标志 $last = m - 1$，然后只要 $last \geq 0$：
	- 堆的根结点传送到输出缓冲区，记为 $mval$
	- 从输入缓冲区读入一个数 $r$：
		- 若 $r \leq mval$，则把 $r$ 放到根结点
		- 否则 $last$ 位置的元素放到根节点，把 $r$ 放到 $last$ 位置（**等待下一顺串处理！**），设置 $last = last - 1$
	- 调整堆，得到新的 $mval$
- 算法结束后，内存（RAM）中也填满了不能处理的数据，直接建成堆，留待下一顺串来处理

**分析**
- 输出的一个顺串最小长度是 $m$，最优长度为整个文件（正序输入），平均情况为 $2m$


<div class="question-box">
    <span class="title">(2021 秋)</span>
    <p>设依次输入降序关键码序列 <b>k1 > k2 > … > kn</b>, 缓冲区大小为 <b>m</b>. 在 <b>n=250</b>, <b>m=25</b> 的情况下,用最小值堆进行置换-选择排序, 可产生初始归并段的个数为 _______; 如果 <b>k1 < k2 < … < kn</b>, 用最小值堆进行置换-选择排序, 可产生初始归并段的个数为 ________.</p>
</div>

**答案：** 10, 1

---
## 多路归并

- 对于每趟需要归并的 $k$ 个顺串, 每步就是 $k$ 个指针扫描, 直到全部 $n$ 个顺串合并完成. 
- 合并趟数 : $[\log_k m]$
- 优化:
	- 创建尽可能大的初始顺串
	- 把初始顺串长度作为权, 转化为Huffman树最优化问题, 得到一个 k叉Huffman 树, 称为**最佳归并树**

> 进一步优化? 每次比较 $k-1$ 次开销还是太大了, 实际上一些比较可以保留

---
### 赢者树
- 完全二叉树结构, 每个叶子节点表示待归并顺串上的当前元素, 每个内部节点储存胜者 (最小值) 所在顺串的序号. 
- 更新时只需输出对应叶子节点元素, 写入新元素后调整从叶子节点到根节点的路径, 时间复杂度为 $O(\log k)$. 

### 败者树
- 胜者树的优化, 没有本质区别, 但在每个节点保留败者所在顺串的序号, 以及增加一个根节点储存最终胜者
- 也即优化了重构过程, 直接找父节点即可, 无需再与兄弟节点比较 (降低复杂度的常数)

### 时间复杂度
- 原始方法 : $O(nk)$
- 败者树方法 : $O(k+n\log k)$

> 为什么不用堆?
> 堆的每层调整都要对三个值 (父节点、两个子节点) 进行至少两次比较, 使用胜者败者树少一次比较, 败者树相对胜者树更少一次寻址