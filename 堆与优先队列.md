# 堆简介



堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。[STL 中的 `priority_queue`](https://oi-wiki.org/lang/csl/container-adapter/#优先队列) 其实就是一个大根堆。（`priority_queue<int, vector<int>, greater<int>>`是一个小根堆。）

（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。

一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。

一些功能更强大的堆还支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。

习惯上，不加限定提到「堆」时往往都指二叉堆。



### 建堆

自底向上逐步把子树调整成堆，注意保持子树性质

向上调整：

```c++
void up(int x) {
    while(x > 1 && h[x] > h[x / 2]) {
        swap(h[x], h[x / 2]);
        x /= 2;
    }
}
```

向下调整：

```c++
void down(int x) {
    while (x * 2 <= n) {
        int t = x * 2;
        if (t + 1 <= n && h[t + 1] > h[t]) t++;
        if (h[t] <= h[x]) break;
        swap(h[x], h[t]);
        x = t;
    }
}
```



建堆方法一：使用 decreasekey（向上调整）

从根节点开始，按BFS序进行

```c++
void bulid_heap_1() {
    for(i = 1; i <= n; i++) up(i);
}
```

复杂度 $O(nlogn)$



方法二：使用向下调整

```c++
void buld_heap_2() {
    for(i = n; i >= 1; i--) down(i);
}
```

每次合并两个已经调整好的堆。复杂度 $O(n)$


