
无向图的 **最小生成树（MST）** 为边权和最小的生成树。

## Kruskal 算法
Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。

前置知识：
[[并查集]]
[[图的存储]]

伪代码

```
Input. The edges of the graph e, where each element in e is (u,v,w)
	denoting that there is an edge between u and v weighted w.
Ouput. The edges of the MST of the input graph.
Method.
result <- \emptyset
sort e into nondecreasing order by weight w
for each (u,v,w) in the sorted e
	if u and v are not connected in the union_find set
		connect u and v in the union_find set
		result <- result \cup {(u,v,w)}
return result
```

算法虽简单，但需要相应的数据结构来支持……具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。

抽象一点地说，维护一堆 **集合**，查询两个元素是否属于同一集合，合并两个集合。

其中，查询两点是否连通和连接两点可以使用并查集维护。

如果使用 $O(mlogm)$ 的排序算法，并且使用 $O(m\alpha(m,n))$ 或 $O(mlogn)$ 的并查集，就可以得到时间复杂度为 $O(mlogm)$ 的 Kruskal 算法。


## Prim 算法
Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。

具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 $O(1)$ decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 **不一定** 实际跑得更快。

```c++
//使用二叉堆优化的 Prim 算法
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
constexpr int N = 5050, M = 2e5 + 10;

struct E {
	int v, w, x;
} e[M * 2];

int n, m, h[N], cnte;

void adde(int u, int v, int w) { e[++cnte] = E{v, w, h[u]}, h[u] = cnte; }

struct S {
	int u, d;
};

bool operator < (const S &x, const S &y) { return x.d > y.d; }

priority_queue<S> q;
int dis[N];
bool vis[N];

int res = 0, cnt = 0;

void Prim() {
	memset(dis, 0x3f, sizeof(dis));
	dis[1] = 0;
	q.push({1, 0});
	while (!q.empty()) {
		if (cnt >= n) break;
		int u = q.top().u, d = q.top().d;
		q.pop();
		if (vis[u]) continue;
		vis[u] = true;
		++cnt;
		res += d;
		for (int i = h[u]; i; i = e[i].x) {
			int v = e[i].v, w = e[i].w;
			if (w < dis[v]) {
				dis[v] = w, q.push({v, w});
			}	
		}	
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; u, v, w; i <= m; ++i) {
		cin >> u >> v >> w, adde(u, v, w), adde(v, u, w);	
	}
	Prim();
	if (cnt == n) 
		cout << res;
	else 
		cout << "No MST.";
	return 0;
}
```


## 最小生成树的唯一性
考虑最小生成树的唯一性。如果一条边不在 MST 的边集中，并且可以替换与其 权值相同并且在 MST 边集 的另一条边，那么这个 MST 就是不唯一的。

对于 Kruskal 算法，只要计算为当前权值的边可以放几条，实际放了几条，如果这两个值不一样，那么就说明这几条边与之前的边产生了一个环（这个环中至少有两条当前权值的边，否则根据并查集，这条边是不能放的），即最小生成树不唯一。

寻找权值与当前边相同的边，我们只需要记录头尾指针，用单调队列即可在 $O(\alpha(m))$ （m 为边数）的时间复杂度里优秀解决这个问题。（基本与原算法时间相同）


## 次小生成树

### 求解方法
- 求出无向图得最小生成树 $T$ ,设其权值和为 $M$
- 遍历每条未被选中的边 $e = (u ,v, w)$，找到 $T$ 中 $u$ 到 $v$ 路径上边权最大的一条边 $e^{'} =(s,t,w^{'})$，则在 $T$ 中以 $e$ 替换它，可得到一棵权值和为 $M^{'} = M + w - w^{'}$ 的新生成树
- 对所有替换得到的答案 $M^{'}$ 取最小值即可。

可以使用求 [[最近公共祖先（LCA）]] 的倍增算法来预处理 $u, v$ 路径上的边权最大值。


## 瓶颈生成树

### 定义
无向图 $G$ 的瓶颈生成树是这样的一个生成树，它的最大的边权值在 $G$ 的所有生成树中最小。

### 性质
最小生成树是瓶颈生成树的必要不充分条件。

可以用反证法证明。


## 最小瓶颈路

### 定义

无向图 $G$ 中 $x$ 到 $y$ 的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有 $x$ 到 $y$ 的简单路径中是最小的。

### 性质

根据最小生成树定义， $x$ 到 $y$ 的最小瓶颈路上的最大边权等于最小生成树上 $x$ 到 $y$ 路径上的最大边权。虽然最小生成树不唯一，但是每种最小生成树 $x$ 到 $y$ 路径的最大边权相同且为最小值。也就是说，每种最小生成树上的 $x$ 到 $y$ 的路径均为最小瓶颈路。

但是，并不是所有最小瓶颈路都存在一棵最小生成树满足其为树上 $x$ 到 $y$ 的简单路径。


## Kruskal 重构树
