# 第一章：概论



### 数据结构三要素

- 逻辑结构
  - 线性结构
    - 线性表（表，栈，队列，串等）
  - 非线性结构
    - 树（二叉树，Huffman树，二叉搜索树等）
    - 图（有向图，无向图等）
- 存储结构（逻辑结构到物理存储空间的映射）
  - 顺序，链接，索引，散列
- 数据的运算
  - 定义在逻辑结构上的一系列操作以及这些操作在存储结构上的实现；
  - 常用的运算：检索、插入、删除、定位、修改、排序等；
  - 数据的运算是定义在逻辑结构上的，而具体实现是基于存储结构



### 抽象数据三元组

数据对象D，数据关系S，数据操作P



### 算法分析

- 大 $O$ 表示法，上限 $f(n) \leq cg(n)$
- 大 $\Omega$ 表示法，下限 $f(n) \geq cg(n)$
- 大 $\Theta$ 表示法，上下限 $c_1g(n) \leq f(n) \leq c_2g(n)$



---

# 第二章：线性表



### 链表

head 指向头节点，头节点不存储数据

设置头结点的好处：

- 由于开始结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作就和在表的其它位置上操作一致，无须进行特殊处理;
- 无论链表是否为空，其头指针是指向头结点的非空指针（空表中头结点的指针域空），因此空表和非空表的处理也就统一了。 



---

# 第三章：栈和队列



### 出栈序列

给定一个入栈序列，长度为 $n$ ，计算有多少种出栈序列？（Catalan数 $C_n = \frac{\binom{2n}{n}}{n + 1}$)



### 后缀表达式求值

- 转化步骤
  - 按照运算符的优先级对所有的运算单位加括号
  - 将运算符移动到对应括号的前面（前缀表达式）或后面（后缀表达式）
  - 去掉括号，得到前缀或后缀表达式

- 用栈实现：
  - 当输入是操作数，直接输出到后缀表达式序列
  - 当输入的是左括号时，也把它压栈
  - 当输入的是运算符时
    - While (以下循环) 
      - If（栈非空 and 栈顶不是左括号 and 输入运算符的优先级 “≤” 栈顶运算符的优先级）时
        - 将当前栈顶元素弹栈，放到后缀表达式序列中（此步反复循环，直到上述if条 件不成立）; 将输入的运算符压入栈中。
      - Else 把输入的运算符压栈（>当前栈顶运算符才压栈！）



### 循环队列

- 把数组elem[MAXNUM]从逻辑上看成一个环

- 循环队列判空满条件：

  - 附设一变量，头尾相碰时判断头追上尾还是尾追上头
  - 少用一个空间，当尾+1等于头时为满；当头等于尾时为空
    - 队空条件：f = = r;
    - 队满条件：(r+1)%MAXNUM == f



### 利用栈消除递归

  

---

# 第四章：字符串



### KMP算法

#KMP算法

next数组：

先计算前缀数组pi，然后全部右移一项，舍去最后一项，将第0项设置为-1

```c++
vector<int> getNext(string p) {
    int n = p.size();
    vector<int> next(n, 0);
    for(int i = 1; i < n; i++) {
		int j = next[i - 1];
        while(j > 0 && p[i] != p[j]) {
            j = next[j - 1];
        }
        if (p[i] == p[j]) j++;
        next[i] = j;
    }
    for(int i = n - 1; i > 0; i--) {
        next[i] = next[i - 1];
    }
    next[0] = -1;
    return next;
}
```

KMP算法（基于next数组）

```c++
int KMP(string t, string p) {
    int tLen = t.size(), pLen = p.size();
    vector<int> next = getNext(p);
    int tbegin = 0, pbegin = 0;
    while(tbegin < tlen && pbegin < plen) {
        if (pbegin == -1 || t[tbegin] = p[pbegin]) tbegin++, pbegin++; //将next[0]设置为-1的目的在此处体现，避免进入死循环
        else pbegin = next[pbegin];
    }
    if (pbegin >= plen) return t - plen;
    else return -1;
}
```

[[KMP算法]]（一些类KMP算法及其思想）



---

# 第五章：二叉树



[[5-二叉树]]

- 完全二叉树
  - 叶节点只可能在最下面两层出现
  - 路径长度和最短
- **扩充二叉树** : 出现空指针时, 增加一个树叶. 
    - 扩充二叉树是**满二叉树**. 
    - 新增空树叶的个数等于原来二叉树结点个数加1
    - 外部路径长度 = 内部路径长度 $+2$ 内部节点个数 (归纳法证明)

- 任意二叉树：叶子节点数 = 满节点数 + 1
  - 非空满二叉树情形下的该性质称为**满二叉树定理**，此时叶子节点数 = 内部节点数 + 1（内部节点都是满节点）
  - **满二叉树定理推论**: 空子树数 = 节点数 + 1
- **层数**：根为第0层
- **深度**：最大层数
- 高度 = 深度 + 1



### 非递归DFS

- 用栈实现（模拟编译栈，在递归的入口处，用栈保存返回地址）
- 前序

```pseudocode
栈S,x = root
while(x)：
    visit(x)
    if (x->rightchild != NULL) S.push(x->rightchild)
    if (x->leftchild != NULL) x = x->leftchild
    else x = S.pop()
```

- 中序

```pseudocode
while(x || !S.empty()):
    if (x)
        S.push(x)
        x = x->leftchild
    else
        x = S.pop()
        visit(x)
        x = x->rightchild
```

- 后序

```pseudocode
while(x || !S.empty())
	while(x): //先把左子树所有根节点压栈
		x.tag = left //设置是从左子树返回
        S.push(x)
        x = x->leftchild
	x = S.pop()
    if (x.tag = left) //如果是从左子树返回
    	x.tag = right //设置是从右子树返回 
    	S.push(x)
    	x = x->rightchild //遍历右子树
   	else //如果是从右子树返回
   		visit(x)
   		x = NULL //将x设置为空节点，以继续弹栈
```



### BFS遍历

用队列实现



### 二叉搜索树（BST）

也称二叉排序树

- 检索x 
- 插入x
- 删除x ： 左子树替代x，右子树移植在左子树最大值节点上 or **删除左子树最大值节点，最大值替代x** （没有左子树的话直接用右子树根节点替代x）
  - 后者可以防止高度失衡



### 堆与优先队列

[[堆与优先队列]]



### Huffman编码树

[[Huffman编码]]



---

# 第六章：树

- **有向有序树**：有序是指子树间有次序
  - 度为2的有序树 $\neq$ 二叉树：前者的单边节点的子树不区分左右，都是第一子树



### 树形结构的表示法

- 树形表示法
  画树状图
- 形式语言表示法
定义节点集合和关系集合
- 文氏图表示法
用Venn 图的包含表示树的有向边
- 凹入表表示法
类似图书目录
- 嵌套括号表示法
迭代 Node()()



### 森林的遍历

- 先根dfs = 前序遍历二叉树
- 后根dfs = 中序遍历二叉树
- bfs : 同深度层被定义为二叉树储存结构的右斜线, 不能用二叉树的广度遍历模版



### 树的存储

#### 子结点表示法
实质上就是图的邻接表

- 优势: 
  - 查孩子个数, 结点值, 归并与删除 
- 劣势: 
  - 找兄弟结点



#### 动态表示法
每个节点包含值和**所有**子节点指针
– 每个结点分配可变的存储空间 (若子结点数目发生变化, 需要重新分配存储空间)



#### "左孩子/右兄弟"表示法
每个节点包含: ***第一个**子节点, ***下一个**兄弟节点, 节点值, (父亲节点)
> 笔记符号说明: *表示指针, ()表示备选
- 优点：
  - 节省空间
- **静态**用数组实现, **动态**用类实现
> 本质是二叉树与森林间的双射

> 一些方法
> **寻找父结点**
> - 本质上是树/森林的遍历 
>  - 直观的做法用队列+while循环遍历森林即可, 递归方法则只适合树的遍历. 
>
> **镜像变换**
> - 我认为应该递归, 对每个节点的处理是先有序地找到所有子节点, 再修改自身左子树指针和子节点的右兄弟指针, 最后对所有子节点递归. 
>
> **删除给定树根的子树**
> - 非常繁琐
