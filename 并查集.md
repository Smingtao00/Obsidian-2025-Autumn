#并查集

# 引入

并查集是一种用于处理等价关系和等价类的数据结构（即用于管理元素所属集合），实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

顾名思义，并查集支持两种操作：

- 合并（Unite）：合并两个元素所属的集合（合并对应的树）
- 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合。

并查集在经过修改后可以支持单个元素的删除、移动或维护树上的边权。使用动态开点线段树还可以实现 [可持久化并查集](https://oi-wiki.org/ds/persistent-seg/#拓展基于主席树的可持久化并查集)。

> [!warning]
>
> 并查集无法以较低复杂度实现集合的分离

## 初始化

初始时，每个元素都位于一个单独的集合，表示为一棵只有根节点的树。方便起见，我们将根节点的父亲设为自己。

```c++ {.line-numbers}
struct dsu {
    vector<size_t> pa;
    
    explicit dsu(size_t size) : pa(size) {iota(pa.begin(), pa.end(), 0);}
}
```

## 查询

我们需要沿着树向上移动，直到找到根节点。

![img](https://oi-wiki.org/ds/images/disjoint-set-find.svg)

```c++ {.line-numbers}
size_t dsu::find(size_t x) { return pa[x] == x ? x : pa[x] = find(pa[x])}
```

这里用到==路径压缩==：查询过程中经过的每个元素都属于该集合，故可以直接将其连到根结点以加快后续查询。

![img](https://oi-wiki.org/ds/images/disjoint-set-compress.svg)

## 合并

要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。

![img](https://oi-wiki.org/ds/images/disjoint-set-merge.svg)

```c++ {.line-numbers}
void dsu::unite(size_t x, size_t y) {pa[find(x)] = find(y);}
```

## 启发式合并

合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。

> [!tip] 具体复杂度分析
>
> 由于需要我们支持的只有集合的合并、查询操作，当我们需要将两个集合合二为一时，无论将哪一个集合连接到另一个集合的下面，都能得到正确的结果。但不同的连接方法存在时间复杂度的差异。具体来说，如果我们将一棵点数与深度都较小的集合树连接到一棵更大的集合树下，显然相比于另一种连接方案，接下来执行查找操作的用时更小（也会带来更优的最坏时间复杂度）。
>
> 当然，我们不总能遇到恰好如上所述的集合——点数与深度都更小。鉴于点数与深度这两个特征都很容易维护，我们常常从中择一，作为估价函数。而无论选择哪一个，时间复杂度都为 𝑂(𝑚𝛼(𝑚,𝑛))![O (m\alpha(m,n))](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，具体的证明可参见 References 中引用的论文。
>
> 在算法竞赛的实际代码中，即便不使用启发式合并，代码也往往能够在规定时间内完成任务。在 Tarjan 的论文[1](https://oi-wiki.org/ds/dsu/#fn:tarjan1984worst)中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度是 𝑂(𝑚log⁡𝑛)![O (m \log n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。在姚期智的论文[2](https://oi-wiki.org/ds/dsu/#fn:yao1985expected)中，证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是 𝑂(𝑚𝛼(𝑚,𝑛))![O (m\alpha(m,n))](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。
>
> 如果只使用启发式合并，而不使用路径压缩，时间复杂度为 𝑂(𝑚log⁡𝑛)![O(m\log n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。

按秩合并的参考实现：（注意需要调整初始化方法）

```c++ {.line-numbers}
struct dsu {
    vector<size_t> pa, size;
    
    explicit dsu(size_t size_) : pa(size_), size(size_, 1) {
        iota(pa.begin(), pa.end(), 0);
    }
    
    void unit(size_t x, size_t y) {
        x = find(x), y = find(y);
        if (x == y) return;
        if (size[x] < size[y]) swap(x, y);
        pa[y] = x;
        if (size[x] == size[y]) size[x]++;
    }
}
```

## 拓展操作

[[带删除并查集]]

[[带权并查集]]

## 其他应用

[[最小生成树]]算法中的Kruskal 和 [[最近公共祖先（LCA）]]中的 Tarjan 算法是基于并查集的算法。
