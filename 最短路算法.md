
## Floyed 算法
用来求任意两个结点之间的最短路，复杂度比较高，但是常数小，容易实现（只有三个 `for`）
适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）

### 实现
我们定义一个数组 `f[k][x][y]` ，表示只允许经过结点 $1$ 到 $k$，结点 $x$ 到结点 $y$ 的最短路长度。
显然，`f[n][x][y]` 就是结点 $x$ 到结点 $y$ 的最短路长度。
接下来考虑如何求出 `f` 数组的值。
`f[0][x][y]` : $x$ 与 $y$ 的边权，或者为 $0$ ，或者为 $+\infty$ 。
`f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k] + f[k-1][k][y]`

```c++
for (k = 1; k <= n; k++) {
	for (x = 1; x <= n; x++) {
		for (y = 1; y <= n; y++) {
			f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);
		}
	}
}
```

因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成 `f[x][y] = min(f[x][y], f[x][k] + f[k][y]` 。

> [!tip]+ 
> 对于给定的 `k` ，当更新 `f[k][x][y]` 时，涉及的元素总是来自 `f[k-1]` 数组的第 `k` 行和第 `k` 列。然后我们可以发现，对于给定的 `k` ，当更新 `f[k][k][y]` 或 `f[k][x][k]` 时，总是不会发生数值更新，因为按照公式 `f[k][k][y] = min(f[k-1][k][y], f[k-1][k][k]+f[k-1][k][y])`，`f[k-1][k][k]` 为 $0$ ，因此这个值总是 `f[k-1][k][y]` ，对于 `f[k][x][k]` 的证明类似。
> 因此，如果省略第一维，在给定的 `k` 下，每个元素的更新中使用到的元素都没有在这次迭代中更新，因此第一维的省略并不会影响结果。

```c++ {.line-numbers}
for (k = 1; k <= n; k++) {
	for (x = 1; x <= n; x++) {
		for (y = 1; y <= n; y++) {
			f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
		}
	}
}
```

### 应用
> [!question]+ 给一个正权无向图，找一个最小权值和的环。
> 首先这一定是一个简单环。
> 想一想这个环是怎么构成的。
> 考虑环上编号最大的结点 $u$ 。
> `f[u-1][x][y]` 和 $(u,x),(u,y)$ 共同构成了环。
> 在 Floyd 的过程中枚举 $u$ ，计算这个和的最小值即可。
> 时间复杂度为 $O(n^3)$ 。
> 更多参见 [最小环](https://oi-wiki.org/graph/min-cycle/) 部分内容。

> [!question]+ 已知一个有向图中任意两点之间是否有连边，要求判断任意两点是否连通。
> 该问题即是求 **图的传递闭包** 。
> 我们只需要按照 Floyd 的过程，逐个加入点判断一下。
> 只是此时的边权变为 $1/0$ ，而取 $min$ 变成了 **或** 运算。
> 再进一步用 bitset 优化，复杂度可以到 $O(\frac{n^3}{w})$ 。
> ```c++
>// std::bitset<SIZE> f[SIZE];
>for (k = 1; k <= n; k++)
>	for (i = 1; i <= n; i++) 
>		if (f[i][k]) f[i] = f[i] | f[k];	 		
> ```
> `f[i][j] = 1` 表示结点 `i` 可以到达结点 `j` 。
> `f[i]` 表示 `i` 直接可达的所有结点。


---
## Bellman-Ford 算法
Bellman-Ford 算法是基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。
「SPFA」，就是 Bellman–Ford 算法的一种实现。

### 过程
对于边 $(u,v)$ ，松弛操作对应下面式子：$dis(v) = min(dis(v), dis(u) + w(u,v))$ 。

这么做的含义：我们尝试用 $S \rightarrow u \rightarrow v$ （其中 $S \rightarrow u$ 的路径取最短路）这条路径去更新 $v$ 点最短路的长度， 如果这条路径更优，就进行更新。

Bellman–Ford 算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。

每次循环是 $O(m)$ 的，那么最多会循环多少次？

在最短路存在的情况下，每一次松弛操作会使最短路的边数至少 $+1$ ，而最短路的边数最多为 $n - 1$ ，因此整个算法最多执行 $n - 1$ 轮松弛操作。故总时间复杂stt度为 $O(nm)$ 。

但还有一种情况，如果从 $S$ 点出发，抵达一个负环时，松弛操作会无休止地进行下去。因此如果第 $n$ 轮循环时仍然存在能松弛地边，说明从 $S$ 点出发，能够抵达一个负环。

> [!warning]+ 负环判断中存在的常见误区
>  需要注意的是，以 $S$ 点为源点跑 Bellman–Ford 算法时，如果没有给出存在负环的结果，只能说明从 $S$ 点出发不能抵达一个负环，而不能说明图上不存在负环。
>  因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。

### 实现
```c++
struct Edge {
    int u, v, w;
};
vector<Edge> edge;

int dis[MAXN], u, v, w;
constexpr int INF = 0x3f3f3f3f;

bool bellmanford(int n, int s) {
    memset(dis, 0x3f, (n + 1)* sizeof(int));
    dis[s] = 0;
    bool flag = false; //判断一轮循环过程中是否发生松弛操作
    for (int i = 1; i <= n; i++) {
        flag = false;
        for (int j = 0; j < edge.size(); j++) {
            u = edge[j].u, v = edge[j].v, w = edge[j].w;
            if (dis[u] == INF) continue;
            // 无穷大与常数加减仍然为无穷大
            // 因此最短路长度为 INF 的点引出的边不可能发生松弛操作
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                flag = true;
            }
        }
        // 没有可以松弛的边就停止算法
        if (!flag) {
            break;
        }
    }
    // 第 n 轮循环任然可以松弛时说明 s 点可以抵达一个负环
    return flag;
}
```



### 队列优化：SPFA

即 Shortest Path Faster Algorithm.

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护 **哪些结点可能会引起松弛操作** ，就能只访问必要的边了。

```c++
struct edge {
    int v, w;
};

vector<edge> e[MAXN];
int dis[MAXN], cnt[MAXN], vis[MAXN];
queue<int> q;

bool spfa(int n, int s) {
    memset(dis, 0x3f, (n + 1) * sizeof(int));
    dis[s] = 0, vis[s] = 1;
    q.push(s);
    while (!q.empty()) {
		int u = q.front();
        q.pop(), vis[u] = 0;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1; //记录最短路经过的边数
                if (cnt[v] >= n) return false;
                // 在不经过负环的情况下，最短路至多经过 n - 1 条边
                // 因此如果经过了多于 n 条边，一定说明经过了负环
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
    return true;
}
```

虽然大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度为 $O(nm)$ ，将其卡到这个复杂度也是不难的。（在没有负权边时最好使用 Dijkstra 算法）



---

## Dijkstra 算法

Dijkstra 算法由荷兰计算机科学家 E. W. Dijkstra 于 1956年发现，1959 年公开发表。是一种求解 **非负权图** 上单源最短路径的算法。



### 过程

将结点分成两个集合：已确定最短路长度的点集（记为 $S$ 集合）和为确定最短路长度的点集（记为 $T$ 集合）。一开始所有的点都属于 $T$ 集合。

初始化 $dis(s) = 0$，其他点的 $dis$ 均为 $+\infty$ 。

然后重复这些操作：

1. 从 $T$ 集合中，任取一个最短路长度最小的结点，移到 $S$ 集合中。
2. 最那些刚刚被加入 $S$ 集合的结点的所有出边执行松弛操作。

直到 $T$ 集合为空，算法结束。



### 优先队列实现

```c++
struct edge {
    int v, w;
};

struct node {
	int dis, u;
    
    bool operator > (const node & a) const { return dis > a.dis; }
};

vector<edge> e[MAXN];
int dis[MAXN], vis[MAXN];
priority_queue<node, vector<node>, greater<node>> q;

void dijkstra(int n, int s) {
	memset(dis, 0x3f, (n + 1) * sizeof(int));
    memset(vis, 0, (n + 1) * sizeof(int));
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty()) {
		int u = q.top().u;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}
```

时间复杂度 $O(mlogn)$





 









