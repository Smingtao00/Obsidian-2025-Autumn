#图的存储

## 邻接矩阵

使用一个二维数组 `adj` 来存边，其中 `adj[u][v]` 为 1 表示存在 $u$ 到 $v$ 的边，为 0 表示不存在。如果是带边权的图，可以在 `adj[u][v]` 中存储 $u$ 到 $v$ 的边权。

```c++
#include <iostream>
#include <vector>

using namespace std;

int n, m;
vector<bool> vis;
vector<vector<vool>> adj;

bool find_edge(int u, int v) { return adj[u][v]; }

void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    for (int v = 1; v <= n; ++v) {
        if (adj[u][v]) {
            dfs(v);
        }
    }
}

int main() {
    cin >> n >> m;
    
    vis.resize(n + 1);
    adj,resize(n + 1, vector<bool>(n + 1));
    
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = true;
    }
    
    return 0;
}
```

```python
vis = [False] * (n + 1)
adj = [[False] * (n + 1) for _ in range(n + 1)]

for i in range(1, m + 1):
    u, v = map(lambda(x) : int(x), input().split())
    
def find_edge(u, v):
    return adj[u][v]

def dfs(u):
    if vis[u]:
		return
    vis[u] = True
    for v in range(1, n + 1):
        if adj[u][v]:
            dfs(v)
```

邻接矩阵在稀疏图上效率很低，尤其是在点数较多的图上，空间无法承受，所以一般只会在稠密图上使用邻接矩阵。



## 邻接表

使用一个支持动态增加元素的数据结构构成的数组，如 `vector<int> adj[n + 1]` 来存边，其中 `adj[u]` 存储的是点 `u` 的所有出边的相关信息（终点，边权等）。

```c++
#include <iostream>
#include <vector>

using namespace std;

int n, m;
vector<bool> vis;
vector<vector<int>> adj;

bool find_edge(int u, int v) {
  for (int i = 0; i < adj[u].size(); ++i) {
    if (adj[u][i] == v) {
      return true;
    }
  }
  return false;
}

void dfs(int u) {
  if (vis[u]) return;
  vis[u] = true;
  for (int i = 0; i < adj[u].size(); ++i) dfs(adj[u][i]);
}

int main() {
  cin >> n >> m;

  vis.resize(n + 1);
  adj.resize(n + 1);

  for (int i = 1; i <= m; ++i) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
  }

  return 0;
}
```

```python
vis = [False] * (n + 1)
adj = [[] for _ in range(n + 1)]

for i in range(1, m + 1):
    u, v = map(int, input().split())
    adj[u].append(v)
    
def find_edge(u, v):
    for i in range(0, len(adj[u])):
        if adj[u][i] == v:
            return True
    return False

def dfs(u):
    if vis[u]:
        return
    vis[u] = True
    for i in range(0, len(adj[u])):
        dfs(adj[u][i])
```



## 链式前向星

本质上是用链表实现的邻接表，核心代码如下：(边的读入顺序和存储顺序刚好相反)

```c++
//head[u] 和 cnt 的初始值都为 -1
void add(int u, int v) {
    nxt[++cnt] = head[u]; //当前边的后继
    head[u] = cnt; //起点 u 的第一条边
    to[cnt] = v;
}

// 遍历 u 的出边
for (int i = head[u]; i != -1; i = nxt[i]) {
    int v = to[i];
}

//c++风格
vector<int> head, nxt, to;
head.resize(n + 1, -1);

void add(int u, int v) {
	nxt.push_back(head[u]);
    head[u] = to.size();
    to.push_back(v);
}

for (int i = head[u]; i != -1; i = nxt[i]) {
    int v = to[i];
}
```

参考代码

```c++
#include <iostream>
#include <vector>

using namespace std;

int n, m;
vector<bool> vis;
vector<int> head, nxt, to;

void add(int u, int v) {
    nxt.push_back(head[u]);
    head[u] = to.size();
    to.push_back(v);
}

bool find_edge(int u, int v) {
    for (int i = head[u]; i != -1; i = nxt[i]) {
        if (to[i] == v) {
            return true;
        }
    }
    return false;
}

void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    for (int i = head[u]; i != -1; i = nxt[i]) dfs(to[i]);
}

int main()
{
    cin >> n >> m;
    vis.resize(n + 1, false);
    head.resize(n + 1, -1);
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        add(u, v);
    }
}
```

边是带编号的，有时会非常有用，而且如果 `cnt` 的初始值为奇数，存双向边时 `i^1` 即使 `i` 的反边（常用于[[网络流]])