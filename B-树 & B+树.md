## $B$ 树
### $B$ 树的定义
 $m$ 阶 $B$ 树是一棵 $m$ 路查找树，或者为空，或者：
 - 下界：根节点至少有两棵子树，其他非叶结点至少有 $\lceil m / 2\rceil$ 棵子树
 - 上界：每个节点至多有 $m$ 个子树
 - 有 $k$ 个子树的节点有 $k - 1$ 个关键码
 - 所有叶节点都在同一层，有 $\lceil m / 2 \rceil - 1$ 到 $m - 1$ 个关键码

$B$ 树的一个包含 $j$ 个关键码，$j + 1$ 个指针的节点的一般形式为：
- $P_0, K_1, P_1, K_2, P_2, \dots, K_j, P_j$
	- $K_i$ 是关键码值，$K_1 < K_2 < \dots < K_j$
	- $P_i$ 是指向包括 $K_i$ 到 $K_{i+1}$ 的子树的指针

每个关键码对应一个记录指针域

### $B$ 树的特点
- 访问局部性
- 高度平衡
- 父节点关键码值是子节点的分界
- 节点关键码至少一定比例是满的
	- 改进空间利用率，减少检索，更新操作的 I/O 次数
- 外部指针数等于关键码数加一
	- $\sum\limits_\text{外部节点} = 1 + \sum\limits_\text{内部节点}(\text{节点子树数量 - 1})$
	- $节点子树数量 - 1$ 是每个节点的通量
	- 外部 $+1$ 补足根节点的入度。


### $B$ 树的查找
从根节点开始，逐层查找，如果指向空节点，则查找失败。

### $B$ 树的检索长度
假设高度是 $h$，则自定向下检索到叶节点的过程可能需要 $h$ 次读盘，最多 $h + 1$ 次访问

### $B$ 树的插入
- 找到最底层插入
- 若溢出，分裂节点，中间关键码连同新指针插入父节点
- 若父节点溢出，继续分裂，可能一直到根节点（则树升高一层）

> 节点分裂方法，加入插入后节点状态为 $p = (m, A_0, K_1, A_1, \dots, K_m, A_m)$，则拆分成两个节点 $p = (\lceil m/2\rceil-1,A_0,K_1,A_1,\dots,K_{\lceil m/2\rceil-1},A_{\lceil m/2\rceil-1})$ 和 $q=(m-\lceil m/2\rceil,A_{\lceil m/2\rceil},K_{\lceil m/2\rceil+1},A_{\lceil m/2\rceil+1},\dots,K_m,A_m)$，中间关联码 $K_{\lceil m / 2 \rceil}$ 于指向新节点 $q$ 的指针插入父节点

- 访外次数
	- 默认约定：内存足够大，检索时读入的节点，在向上分裂时不必再从磁盘读入（分裂时，需要修改的祖先节点已经在内存中了）
	- 读盘次数与查找相同
	- 最少写盘次数：一次
		- 如不分裂，则仅将插入关键码所在节点写到外存
	- 如考虑对主数据文件访问，则再加一次


### $B$ 树的删除
- 删除的关键码在叶节点
	- 若删除后节点关键码数小于 $\lceil m / 2 \rceil - 1$
		- 若兄弟节点关键码数大于 $\lceil m / 2 \rceil - 1$，则从兄弟节点借关键码（父节点分界关键码也要调整，即从父节点借一个分隔键下来，将兄弟节点的一个键提升成父节点的分割键）
		- 若兄弟节点关键码数等于 $\lceil m / 2 \rceil - 1$，则合并节点（将该节点，父亲节点的一个分隔键，兄弟节点合并成一个新节点，分割键左右的两个指针合并成指向新节点的一个新指针）
	- 若删除后节点关键码数不小于 $\lceil m / 2 \rceil - 1$，则直接删除
- 删除的关键码不在叶节点层
	- 先把次关键码替换为其后继关键码，再删除该关键码


## $B+$ 树
$B$ 树的变种，所有关键码都在叶节点，各层节点中的关键码是下一层相应节点中最大关键码（或最小关键码）的拷贝。

### $B+$ 树的特点
- 每个节点子节点数量在 $[\lceil m / 2 \rceil, m]$，根节点可以只有两个子节点（空，独根除外），这一点与 $B$ 树相同
- $B+$ 树与 $B$ 树的差异
	- $B+$ 树中 $n$ 棵子树的节点中含有 $n$ 个关键码，而 $B$ 树中 $n$ 棵子树的节点中含有 $n - 1$ 个关键码
	- $B+$ 树叶子节点包含了完整的索引的信息，而 $B$ 树的所有节点共同构成全部索引信息
	- $B+$ 树所有的非叶节点可以看成是高层索引，节点中仅含有其子树中最大（或最小）关键码。

### $B+$ 树的查找
查找到叶节点层
- 在上层已找到待查的关键码，并不停止
- 继续沿指针向下查到叶节点层的这个关键码
逐层找：
- $B+$ 树叶节点一般链接起来，形成双链表
	- 适合顺序检索（范围检索）
	- 实际应用更广
	- 需要的话，每一层节点也可以顺序链接


### $B+$ 树的插入
与 $B$ 树类似，左 $\lceil m / 2 \rceil$，右 $\lfloor m / 2 \rfloor$，注意上层关键码的维护（保证上一层节点中有这两个节点的最大关键码或最小关键码）

> 两棵树分裂时都是左节点 $\lceil m / 2 \rceil$ 个节点


### $B+$ 树的删除
与 $B$ 树类似，但被删除关键码的上层副本可以选择保留，作为 "分界关键码" 存在（也可以替换成新的最大关键码或最小关键码）


## 性能分析
$m$ 阶 $B$ 树，关键码为 $N$ 个，内部节点数为 $p$，则存取次数 $k$ 满足
$$k \leq 1 + \log_{\lceil \frac{m}{2} \rceil}(\frac{N+1}{2})$$
- 有 $N + 1$ 个外部空指针
- 假设外部指针在第 $k$ 层
- 第 $0$ 层至少一个节点，第 $1$ 层至少 $2$ 个节点
- 第 $k ( k \geq 2)$ 层至少 $2\cdot \lceil m / 2 \rceil$ 个节点
- $N  + 1 \geq 2 \cdot \lceil m / 2 \rceil^{k - 1}$

当根包含一个关键码，除根外的所有内部节点都包含 $\lceil m / 2 \rceil - 1$ 时，$B$ 树包含的关键码的个数最少，即 
$$N \geq 1 + (\lceil m / 2 \rceil - 1)(p - 1)$$
- 最差情况下每插入一个节点都经过分裂（除第一个），即 $p - 1$ 个节点都是分裂而来的，则每插入一个关键码平均分裂节点个数为 $$s = \frac{{p-1}}{N} \leq \frac{{N - 1}}{(\lceil m / 2 \rceil - 1)\cdot N} \leq \frac{1}{\lceil m / 2 \rceil - 1}$$


## AI 问答

### 1. 为什么需要B树？—— 诞生背景

在理解B树之前，首先要明白它解决的问题。

计算机的存储体系分为**快速但容量小的内存（RAM）** 和**慢速但容量大的外存（如硬盘、SSD）**。当数据量庞大，无法全部装入内存时，就必须存放在磁盘上。

磁盘读取（I/O）的速度比内存慢**几个数量级**。因此，**减少磁盘I/O次数是设计磁盘存储数据结构的首要目标**。

- **传统二叉搜索树（BST）**： 在内存中效率很高（`O(log n)`）。但如果将其直接存到磁盘，每个节点可能位于不同的磁盘页。一次查找可能需要从根访问到叶子，即`O(log n)`次磁盘I/O。当树很高（n很大）时，这个次数是无法接受的。

- **平衡二叉搜索树（如AVL树、红黑树）**： 虽然控制了高度，但它们依然是“**瘦高**”的二叉树，`log₂(n)`的高度在数据量极大时（如数十亿）依然可观，意味着大量的磁盘I/O。


**B树的核心设计思想**： 通过创建一个 **“矮胖”** 的多路搜索树，让每个节点可以包含**多个键和多个子节点指针**。这样，树的高度被极大地压缩，一次磁盘I/O可以读取一个包含大量键的节点（一个磁盘块/页），然后在内存中对其进行快速搜索，从而显著减少总体磁盘I/O次数。

---

### 2. B树的定义和核心特性

B树是一种**自平衡的、多路搜索树**，用于在块设备（如磁盘）上高效存储和检索数据。

#### 关键术语和定义

对于一个 **m阶B树** （通常 m ≥ 3），有以下严格规则：

1. **节点容量**：
    - 每个**内部节点**（非根非叶子）至少有 **`ceil(m/2) - 1`** 个键，至多有 **`m - 1`** 个键。至少有 `ceil(m/2)` 个子节点，至多有 `m` 个子节点。
    - 根节点至少可以有 **1** 个键（除非树为空）。

2. **子节点数量**：
	- 如果一个内部节点有 `k` 个键，那么它必须有 **`k + 1`** 个子节点指针。
    - 所有**叶子节点**都位于同一层，且没有子节点（指针为空）。
   
3. **键的排序**：
    - 节点内的键 `K₁, K₂, ..., Kₖ` 是**升序排列**的。
    - 对于一个键 `Kᵢ`，其**左子树**中所有键都 `< Kᵢ`，其**右子树**中所有键都 `> Kᵢ`。这本质上是二叉搜索树规则在多路情况下的扩展。


#### 一个直观的例子（3阶B树，也叫2-3树）

- m = 3
  
- 每个节点最少键数：`ceil(3/2)-1 = 1`
  
- 每个节点最多键数：`m-1 = 2`
  

```
          [23, 45]                      // 根节点（可以有1-2个键）
         /    |    \
        /     |     \
  [10, 20]  [30, 40]  [50, 60]         // 叶子节点在同一层
```
 
在这个树中，搜索`35`：从根`[23,45]`开始，`35`在`23`和`45`之间，进入第二个子节点`[30,40]`，在内存中线性或二分查找即可找到/判断不存在。整个搜索过程只经历了**2次节点访问**（即2次磁盘I/O）。

---

### 3. B树的核心操作详解

#### **查找（Search）**

与二叉搜索树类似，但在每个节点内部进行多路决策。

1. 从根节点开始。
   
2. 在当前节点中，找到第一个**大于等于**目标值的键。
   
    - 如果相等，则查找成功。
      
    - 如果不等，或者所有键都小于目标值，则沿着目标值所在区间的子节点指针向下。
    
3. 重复步骤2，直到到达叶子节点。如果在叶子节点仍未找到，则目标不存在。  
    **时间复杂度**： `O(logₘ n)`，其中`m`为阶数。由于`m`很大，树非常矮，`logₘ n`很小。
    

#### **插入（Insert）**

插入总是在**叶子节点**进行。

1. **定位叶子**： 使用查找算法，找到目标值应该被插入的叶子节点。
   
2. **插入叶子**： 将新键按顺序插入该叶子节点。
   
3. **处理上溢**： 这是B树保持平衡的关键。如果插入后，叶子节点的键数**超过了最大值（m-1）**，则发生了“上溢”。
   
    - **分裂**： 将该节点的中间键（`m/2`向上取整）**提升**到父节点。
      
    - 原节点分裂为左右两个兄弟节点，键值分别小于和大于被提升的中间键。
      
    - 在父节点中，将提升的键和指向新子节点的指针插入正确位置。
      
    - **递归上溢**： 如果父节点因为这次提升也发生了上溢，则继续向上分裂。这个过程可能一直递归到根节点。
      
    - **根分裂**： 如果根节点上溢，被提升的键会成为一个新的根节点，**这是B树长高的唯一途径**（树长高一层）。
      

**插入示例**： 在3阶B树中插入 `25`。  
插入前：`[10, 20]`, `[30, 40]` （假设是某个父节点的孩子）  
插入`25`到`[20,30]`？不，先找到正确叶子。假设插入到`[20,30,40]`的叶子（已满，m-1=2，现在有3个键，上溢）。

1. 分裂 `[20, 25, 30]`，中间键 `25` 提升。
   
2. 父节点变为 `[... 父原有键, 25 ...]`，并增加两个子指针指向 `[20]` 和 `[30,40]`（原节点分裂而成）。
   

#### **删除（Delete）**

删除比插入更复杂，需要考虑从内部节点删除的情况。

1. **定位目标**： 找到要删除的键所在的节点。
   
2. **情况1：删除键在叶子节点**
   
    - 直接删除。
      
    - **处理下溢**： 如果删除后，叶子节点的键数**少于最小值（ceil(m/2)-1）**，则发生“下溢”。
      
        - **借兄弟**： 检查左右兄弟节点。如果某个兄弟的键有**富余**（>`最小值`），则从父节点借一个分隔键下来，并将兄弟的一个键提升到父节点。
          
        - **合并**： 如果左右兄弟都没有富余，则将该节点、父节点的一个分隔键、以及一个相邻兄弟节点**合并**成一个新节点。
          
        - **递归下溢**： 合并操作会导致父节点失去一个键，可能引发父节点的下溢，需要递归向上处理。
          
        - **根缩并**： 如果根节点在合并后只剩下一个子节点且没有键了，则让这个子节点成为新的根，**这是B树变矮的唯一途径**。
    
3. **情况2：删除键在内部节点**
   
    - 不能直接删除，否则会破坏子节点指针结构。
      
    - **寻找替代键**：
      
        - 可以用其**前驱**（左子树中最右边的键）或**后继**（右子树中最左边的键）来替换它。这个前驱/后继必定在某个叶子节点中。
        
    - 用前驱或后继的值覆盖要删除的键。
      
    - **转为情况1**： 接着，在叶子节点中**删除那个被拿来替换的前驱或后继键**。这就转化为了从叶子节点删除的问题，按情况1处理即可。
      

---

### 4. B树的优点总结

1. **极矮的树高**： 多路设计使树高为 `O(logₘ n)`，`m`通常很大（如几百），即使存储海量数据，高度也很少超过5，意味着**查找任何记录最多只需几次磁盘I/O**。
   
2. **自平衡**： 通过分裂和合并操作，始终保持所有叶子节点在同一层，保证操作的稳定效率。
   
3. **适合磁盘预读**： 磁盘的一次I/O会读取一个数据块（如4KB）。B树的一个节点大小正好设计为一个磁盘块，充分利用了这次I/O，读取一个节点后可以在内存中高效处理其中的大量键。
   
4. **支持范围查询**： 由于键值有序，进行范围查询（如`BETWEEN 10 AND 100`）比哈希表等结构更高效。
   

---

### 5. B树 vs. B+树

在实际的数据库系统和文件系统中（如MySQL的InnoDB引擎），更常见的是**B+树**，它是B树的一个重要变种。主要区别如下：

|特性|B树|B+树|
|---|---|---|
|**数据存储**|键和对应的数据记录可以存放在**所有节点**中。|**数据记录（或指向记录的指针）只存放在叶子节点**。内部节点仅存储键，作为导航索引。|
|**叶子节点**|叶子节点与其他节点结构相同，不包含全部数据。|**所有叶子节点通过指针串联成一个有序链表**。|
|**查找性能**|可能在内部节点找到数据，查找不稳定（有时快有时慢）。|任何查找都必须到达叶子节点，查找路径长度稳定。|
|**范围查询**|需要进行中序遍历，效率较低。|**极其高效**。只需要在叶子节点的链表上遍历即可。|
|**空间利用率**|内部节点也存数据，相对较低。|内部节点纯索引，可以存储更多键，树更矮，I/O更少。|

**结论**： B+树因其更适合磁盘存储特性（特别是范围查询和顺序访问）而成为数据库索引的**事实标准**。当我们一般谈论“数据库索引使用的B树”时，通常指的就是B+树。


### 1. 关键概念区分：扇区 vs. 磁盘块/页

- **扇区**： 这是**硬盘硬件**本身的最小可寻址和读写单位。传统硬盘一个扇区是 **512字节**，现代高级格式硬盘是 **4096字节（4K）**。它是物理层面的概念。
    
- **磁盘块/页**： 这是**操作系统文件系统**或**数据库管理系统**进行I/O操作的最小逻辑单位。它的大小通常是扇区大小的整数倍，并且是内存**页框**大小的整数倍。常见的大小是 **4KB， 8KB 或 16KB**。这是软件和系统层面进行数据交换的基本单元。
    

### 2. B树节点与“磁盘块/页”的关系

B树设计的黄金法则是：**“一个节点，一次磁盘I/O”**。

1. **大小匹配**： 在实现B树时，我们会将**一个节点**（包括其包含的所有键、子节点指针以及可能的附加信息）的序列化大小，精心设计为恰好等于或略小于一个**磁盘块/页**的大小（例如4KB）。
    
2. **I/O操作**：
    
    - **读取**： 当程序需要访问一个B树节点时（例如从根节点开始搜索），磁盘控制器会**一次性将整个节点所在的整个磁盘块（如4KB）** 读入内存。即使你只关心节点里的一个键，这也是最小的读取单位。
        
    - **写入/更新**： 当节点被修改（如插入导致分裂），系统会将修改后的整个节点**写回一个磁盘块**。
        

### 3. 为什么这样做？（设计哲学再现）

这完美呼应了B树诞生的初衷：**最小化昂贵的磁盘I/O次数**。

- **效率最大化**： 既然一次磁盘I/O无法避免，那就让它读取尽可能多的、相关的数据。一个4KB的节点里可以存放数百个键（取决于键的大小），这比“瘦高”的二叉树每次I/O只读一个键要高效无数倍。
    
- **预读优势**： 现代磁盘和操作系统有预读优化。顺序读取相邻扇区的成本很低。将节点放在连续的块中，可以进一步利用这个优势。
    
- **管理方便**： 与内存分页机制协同工作，便于缓存和缓冲区管理。
    

### 4. 一个具体化的例子

假设我们有一个用于数据库索引的B+树：

- **磁盘页大小**： 16 KB
    
- **键**： 一个64位的整数（如主键ID，8字节）
    
- **子节点指针**： 一个6字节的磁盘地址（文件号+页号）
    
- **一个内部节点**： 存储键和指针。
    
    - 粗略计算，每个（键+指针）对大约14字节。
        
    - 一个16KB的页，扣除少量页头信息，大约能存储 `(16 * 1024) / 14 ≈ 1170` 个键值对。
        
    - 这意味着这个内部节点可以有大约1170个子节点指针。
        

**结论**： 一次磁盘I/O（读取16KB），我们就将搜索范围缩小了1170倍。只需3-4次I/O，就能从根节点遍历到叶子节点，在数十亿条记录中定位到目标。这就是B树“矮胖”威力的直接体现。

### 总结回答您的问题：

**B树的每个内部节点（以及叶子节点）在物理存储上，并不是直接对应一个硬件“扇区”，而是对应一个或一组连续的“磁盘块”或“页”（操作系统/数据库的I/O单位）。其大小被精心设计，以使得一次磁盘I/O操作能够完整读写一个节点，从而将磁盘访问次数降到最低。**