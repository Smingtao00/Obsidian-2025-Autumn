> 继承自xj学长 DSA-A 笔记 11-索引 红黑树部分，补充 红黑树的删除内容~~（虽然不考）~~

#红黑树

### 定义
BST的染色版:
- 每个节点要么是红色, 要么是黑色
- 根节点, 叶节点是黑色
- 父子节点不能同时为红色
- 任意结点到叶节点的路径上黑色结点数相同

**节点的阶**
- 即从该节点到叶节点的黑色节点数, 不包括该节点本身, 包括叶节点
- 叶节点的阶为0, 根节点的阶为该树的阶

**红黑树的性质**
- 满二叉树 : 空树叶也看作节点
- $k$ 阶红黑树树高 $\in [k+1,2k+1]$
- $k$ 阶红黑树内部节点数最少是 $2^k-1$
- $n$ 个内部节点的红黑树树高最大是 $2\log_2(n+1)+1$
- 红黑树检索, 插入, 删除的最差时间都是 $O(\log n)$

### 操作
**左旋与右旋** ->左旋(x), <-右旋(y)
```
    x              y
   / \            / \
  a   y    <->   x   c
     / \        / \  
    b   c      a   b 
```
保留BST的性质, 旋转后的树的中序遍历结果不变 $(a<A<b<B<c)$

**红黑树的插入**
- 插入节点为红色
- 若父节点为黑色, 不违反性质, **直接插入**
- 若父节点为红色, 则祖父黑, 不妨设父节点在左, 叔节点在右 
  - 如果没有叔节点, 则视其为黑色
  - 叔节点为红色, 则将父节点, 叔节点染黑, 祖父节点染红, **递归**调整祖父节点 (若祖父节点为根节点, 则不必染红)
  - 叔节点为黑色, 且当前节点为右子节点, 则左旋父节点, **转化**为左子节点的情况
  - 叔节点为黑色, 且当前节点为左子节点, 则右旋祖父节点, 旋转前的祖父节点染红, 父节点染黑, **结束**
- 时间复杂度 $O(\log n)$, 因为递归调整的次数不超过树高的一半

**BST的删除**
- 没有儿子, 直接删除
- 有一个儿子, 用儿子替代
- 有两个儿子, 找到右子树的最小节点(即从右子树根出发递归找左儿子), 用该节点替代, 再删除该节点 (该节点最多只有一个右儿子) (或者找左子树的最大节点)

**红黑树的删除** : 
- 有两个儿子：
	- 与直接前驱（或直接后继），即左子树的最大结点交换值，转化为删除原左子树的最大结点
	- 该结点最多只有一个左儿子（不考虑 nil（外部空节点））
	- 转化为下述情况
	
- 有一个儿子：
	- 一定是该结点为黑，儿子为红（否则有两条路径上黑结点数目不一致）
	- 儿子代替父亲，儿子染黑，删除父亲
	
- 没儿子（最复杂）
	- 红色结点：直接删除
	
	- 黑色结点：需要考虑兄弟结点和兄弟节点的孩子结点
	
	  不妨设该结点为左子节点，兄弟结点为右子节点（否则对称地操作即可）
	
	  - case 1：
	
	    <img src="C:\Users\浪涛依旧铭记\AppData\Roaming\Typora\typora-user-images\image-20251224150937847.png" alt="image-20251224150937847" style="zoom:50%;" />
	
	    兄弟结点右子节点为红
	
	    如上图，D 变成 S 的颜色，S 变成 P 的颜色，P 变成黑色；然后 P 左旋，S 变成子树根节点；N 变 nil（删除）
	
	  - case 2：兄弟节点左子结点为红
	
	    <img src="C:\Users\浪涛依旧铭记\AppData\Roaming\Typora\typora-user-images\image-20251224151622566.png" alt="image-20251224151622566" style="zoom:50%;" />
	
	    S 右旋，交换 C 和 S 的颜色即化为 case 1
	
	  - case 3：兄弟节点只有黑孩子（空叶子结点也是黑孩子）
	
	    <img src="C:\Users\浪涛依旧铭记\AppData\Roaming\Typora\typora-user-images\image-20251224151923943.png" alt="image-20251224151923943" style="zoom:50%;" />
	
	    N 变 nil（删除），将 S 染红，递归处理 P 即可（若 P 是红色，直接染黑，return）
	
	    