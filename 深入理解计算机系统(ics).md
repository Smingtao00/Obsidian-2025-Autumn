#ics

[[深入理解计算机系统 (Randal E. Bryant, David R. O’Hallaron) (Z-Library).pdf]]
# 第一章：计算机系统漫游



---

# 第二章：信息的表示和处理



---

# 第三章：程序的机器级表示

## 栈的结构，栈顶储存%rsp

这里注意，栈实际上是内存的一块区域，且栈底在高地址区：
因此==入栈是让%rsp减小== ，==出栈是%rsp增加==

## 栈相关操作指令

- 入栈（%rsp - 8）

-  出栈（%rsp + 8）

### 调用与返回（call & return）

- call指令实际做的事：
	1. 减少栈指针
	2. 将返回地址存入栈（属于当前函数的栈帧）
	3. 将被调用函数第一条命令的地址写入%rip(程序计数器)
- 实际效果为：存储返回地址，下一条指令运行子函数
- ret指令实际做的事：
	   1. 增加栈指针
	   2. 将弹出的地址放入%rip中
- 实际效果为：弹出返回地址，并回到原函数中应该去的地方 
- 
- %rip程序计数器存储下一条指令的地址（由此实现跳转）
- 返回地址：call的下一条指令的地址

## 传参

### 传入的参数
- 前六个参数：通过寄存器传递，依次为==%rdi , %rsi , %rdx , %rcx , %r8 , %r9==
- 大于六个参数：多出来的用栈传递，从右往左依次压栈（第七个参数在最顶部）
### 返回值
用寄存器%rax（这就是为什么ret不用显示的返回值，因为值已经约定储存在%rax中了）
### call传参实质：
在调用call之前，将参数赋值给对应的寄存器
### 一个有趣的例子：
- scanf中传递参数时：
	- 标准输入放在%rdi中
	- 格式字符串放在%rsi中，且%rsi存的是指向[[基础汇编语言知识#内存结构概览|数据区]]已有格式字符串的指针
	- 第1，2，3，4个读入地址放在%rdx,%rcx,%r8,%r9中
	- 剩余放在栈中
## 栈帧：每一个尚未返回的函数在==栈上==维护的存储空间

### 存储的内容：
- 局部变量
- 返回地址
- 可能需要分配的临时空间
### 栈帧的分配与释放
- 进入函数后先分配栈帧空间
- 函数返回时释放
- %rbp可能会存放指向当前栈帧的起始地址，这个时候%rbp被称为帧指针


## 寄存器使用惯例

 两种保存方式：caller-save & callee-save
### caller-save：调用者保存
- Caller在调用子函数之前将这些寄存器内容保存在它的栈帧内
- 子函数可以随意使用这些寄存器，随意修改（调用子函数前后不保持一致）
- 如：%rax，传参寄存器，%r10，%r11（%r10,%r11用于存储临时变量）
### callee-save 被调用者保存
- callee 在使用这些寄存器前，将其原有内容保存在栈帧内，且==退出前复原寄存器的值==
- 保存方式一般为入栈
- 该种寄存器的值在调用子函数前后保持一致
- 如：%rbx，%rbp，%rsp，%r12，%r13，%r14
- 经典的例子比如：%rsp--分配了空间，在ret前一定会%rsp++使其恢复原样。


## gdb

#gdb

| 指令        | 全称  | 描述                                             |
| :---------- | ----- | ------------------------------------------------ |
| r           | run   | 开始执行程序，直到下一个断点或程序结束           |
| q           | quit  | 退出GDB调试器                                    |
| ni          | nexti | 执行下一条指令，但不进入函数内部                 |
| si          | stepi | 执行当前指令，如果是函数调用则进入函数           |
| b           | break | 在指定位置设置断点                               |
| c           | cont  | 从当前位置继续执行程序，直到下一个断点或程序结束 |
| p           | print | 打印变量的值                                     |
| x           |       | 打印内存中的值                                   |
| j           | jump  | 跳转到程序指定位置                               |
| disas       |       | 反汇编当前函数或指定的代码区域                   |
| layout asm  |       | 显示汇编代码视图                                 |
| layout regs |       | 显示当前的寄存器状态和它们的值                   |

关闭`layout`的方式为，按下`Ctrl + x`，然后再按下`a`。

关于 `p` 和 `x`，最重要的就是记得 `p` 命令用于打印表达式的值，而 `x` 命令则主要用于检查内存的内容。几个常用示例如下：

```bash
p $rax  # 打印寄存器 rax 的值
p $rsp  # 打印栈指针的值
p/x $rsp  # 打印栈指针的值，以十六进制显示
p/d $rsp  # 打印栈指针的值，以十进制显示

x/2x $rsp  # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。
x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。

x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。
x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。
x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。
x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。

info registers  # 打印所有寄存器的值
info breakpoints  # 打印所有断点的信息

delete breakpoints 1  # 删除第一个断点，可以简写为 d 1
```

这些命令在 `/` 后面的后缀（如 `2x`、`2d`、`s`、`g`、`20c`）指定了查看内存的方式和数量。具体来说：

- 第一个数字（如 `2`、`20`）指定要查看的单位数量。

- 第二个字母（如 `x`、`d`、`s`、`g`、`c`）指定单位类型和显示格式，其中：

  - `c` / `d` / `x` 分别代表以字符 / 十进制 / 十六进制格式显示内存内容。

  - `s` 代表以字符串格式显示内存内容。

  - `b` / `h` / `w` / `g` 分别代表以 1 / 2 / 4 / 8 字节为单位（`unit`）显示内存内容。

    当使用 `x/b`、`x/h`、`x/w`、`x/g` 时，`unit` 会保留对应改变，直到你再次使用这些命令。



`gdb` 有一个很实用的功能，就是我们可以使用 `.gdbinit` 文件来设置 `gdb` 进入时的一些默认配置，这样我们就不用每次都手动输入一大堆的指令。

为了实现此功能，我们首先进行如下配置：

```bash
# 创建当前目录下的 .gdbinit 文件
touch .gdbinit
# 创建 .config/gdb 文件夹
mkdir -p ~/.config/gdb
# 允许 gdb 预加载根目录下所有的文件
echo "set auto-load safe-path /" > ~/.config/gdb/gdbinit
```

然后，我们打开工作目录的 `.gdbinit` 文件，输入如下内容：

```bash
# ./gdbinit
# 设置默认文件输入，这样我们不必每次手动输入答案
set args psol.txt

# 可以为 explode_bomb 函数设置断点，这样我们就可以在爆炸之前打断程序的执行
# 但是由于其会打印输出信息，所以后面有更具有针对性的设置，跳过信息发送函数
# 所以这里就不再设置断点了
# b explode_bomb

# 为各个 phase 函数设置断点，用以观察其执行过程
# 如果你做完了某个 phase，可以将其注释掉，这样就不会再进入该 phase 了
b phase_1
b phase_2
b phase_3
b phase_4
b phase_5
b phase_6

# 为校验函数设置断点
b phase_defused
# 为此断点编程
command
# 直接跳到返回语句处，跳过校验流程
jump *(phase_defused + 0x2A)
end


# 以下代码务必保留!!!

# 为 explode_bomb 中触发 send_msg 函数的地方设置断点
b *(explode_bomb + 0x44)
# 为此断点编程
command
# 直接跳到 exit 退出函数处，跳过发送信息流程
j *(explode_bomb + 0x81)
end

# 炸弹已经安全化，可以放心地拆弹了，开始运行程序
r
```



## x86-64知识课堂

#栈溢出保护

在 x86/x86-64 汇编中，%fs:0x28 表示访问 **FS 段寄存器指向的内存区域中偏移量为 0x28 的位置**，其具体含义与操作系统和应用场景密切相关，在 Linux 系统中最常见的用途是 **栈溢出保护（Stack Canary，栈金丝雀）**。

#### 背景：FS 段寄存器的作用

FS 是 x86 架构中的一个段寄存器，在现代操作系统（如 Linux、Windows）中，它通常用于指向 **线程本地存储（TLS，Thread-Local Storage）**—— 即每个线程独有的数据区域（如线程私有变量、调试信息等），而非传统实模式下的内存分段。

#### Linux 中 %fs:0x28 的具体含义：栈金丝雀

在 Linux 系统（尤其是使用 glibc 的程序）中，%fs:0x28 通常存储一个 **随机生成的栈金丝雀值（Stack Canary）**，用于检测栈溢出攻击。其工作原理如下：

1. **函数进入时（Prologue）**：

编译器会自动生成代码，将 %fs:0x28 处的金丝雀值复制到当前函数的栈帧中（通常位于返回地址下方）。

1. **函数退出时（Epilogue）**：

代码会检查栈帧中的金丝雀值是否与 %fs:0x28 处的原始值一致。

- 若一致：栈未被溢出，正常返回。

- 若不一致：说明栈可能被恶意溢出（例如缓冲区溢出覆盖了金丝雀和返回地址），程序会立即终止（触发 __stack_chk_fail 异常）。

#### 示例：栈金丝雀的使用流程

以一个简单函数为例，编译器生成的汇编可能包含类似逻辑：

```
; 函数进入时，将金丝雀存入栈帧
mov    %fs:0x28, %rax    ; 读取 %fs:0x28 处的金丝雀值到 rax
mov    %rax, -0x8(%rbp)  ; 存入栈帧（rbp-8 位置）

; ... 函数逻辑 ...

; 函数退出时，检查金丝雀
mov    -0x8(%rbp), %rax  ; 从栈帧读取金丝雀
xor    %fs:0x28, %rax    ; 与原始值异或（若相同则结果为 0）
je     .L正常返回         ; 异或结果为 0 → 正常返回
call   __stack_chk_fail  ; 否则触发栈检查失败，程序终止
```

#### 为什么用 %fs:0x28？

- **随机性**：金丝雀值由内核在程序启动时随机生成，且每个进程（或线程）不同，攻击者难以预测。

- **线程隔离**：FS 段指向线程本地存储，确保多线程环境下每个线程的金丝雀值独立，避免干扰。

#### 其他系统中的可能含义

在 Windows 系统中，FS 段通常指向 **线程环境块（TEB，Thread Environment Block）**，但 0x28 偏移的含义与 Linux 不同（可能对应 TEB 中的其他线程私有数据）。不过 %fs:0x28 最广为人知的用途仍是 Linux 下的栈金丝雀。

总结：%fs:0x28 是 Linux 系统中用于栈溢出保护的关键位置，存储随机金丝雀值，是编译器（如 GCC）默认开启的安全机制（-fstack-protector）的核心实现。



## C语言指针类型声明规则

```c {.line-numbers}
int *p; //p是指向int的指针
int **p; //pp是一个指针，指向一个指向int的指针
int *arr[10]; //arr是一个数组，有10个元素，每个元素是一个指向int的指针
int (*p)[10]; //p是一个指针，指向一个包含10个int的数组
int (*funcPtr)(int, int); //funcPtr是一个指针，指向一个函数，该函数接受两个int参数并返回int

const int *p; //p是一个指针，指向一个常量int（不能通过p修改所指向的值）
int const *p； //同上
int *const p; //p是一个常量指针，指向int（不能修改p指向的地址，但可以修改所指向的值）
const int *const p; //p是一个常量指针，指向一个常量int（既不能修改指向的地址，也不能通过p修改值）

typedef int (*FuncPtr)(int, int); //现在FuncPtr是一个类型，表示指向函数的指针
FuncPtr fp; //声明一个函数指针变量fp
```

**复杂声明解析规则——右左法则(Right-Left Rule)**

1. 从标识符开始
2. 向右看直到遇到)或结束
3. 向左看直到遇到(或开始
4. 出括号后重复2、3步骤

**解析示例**

`char *(*array[10])(int);`

- `array` 是一个数组，包含10个元素，每个元素是指针
- 指向函数（接受int参数）
- 函数返回 char 指针

`int (*(*func)(int))[10];`

- `func` 是一个指针，指向一个函数，函数接受一个 int 参数，并返回一个指针，该指针指向一个包含 10 个 int 的数组

`char (*(*x())[])()`

- `x` 是一个函数，返回一个指针
- 该指针指向一个数组
- 数组中的元素是函数指针
- 这些函数返回 char

## 数组

### 实质：连续分配的内存
例：
```cpp
T A[L];
```
分配方式：容量L * sizeof（T）即所需的字节数
而其中A也可以用作T\*类型指针，存储数组的首地址

### 寻址方式
```cpp
//代码写法
void get_digit(int[5] z, int digit){
	return z[digit];
}
```
实际汇编代码
```s
movl (%rdi, %rsi , 4), %eax 
```
%rdi + 4 \* %rsi 即代表z + digit 即 &z\[digit\]

### 指针和数组的区别
- 声明一个数组的时候，不仅创建了一个可以访问的指针，还为其分配了内存空间
- 声明一个指针的时候，并没有分配实际的内存空间
- 因此在只是声明的时候：解引用数组名不会有问题，但解引用指针可能会出现nullptr

### 一些指针和数组的声明方式
- int (\*a)\[4\];   --- 声明一个指针a，指向一个int\[4\]的数组
- int (\*b\[4\]);   ---声明一个数组b，其种元素为int\*  等价于 int\* b\[4\];
- 关键在于：（）\[\]的优先级高于\*，因此
	- int (\*a)\[4\];  中a优先被解释为指针而非数组
	- int (\*b\[4\]);  中b优先被解释为数组而非指针
	- 由此也可以类比理解为什么 int (\*a)(int);  中a是一个函数指针。
### 二维数组
```cpp
T A[R][C];
```
相当于声明了一个数组B\[R\],其中每个元素都是一个D\[C\]
分配的空间为sizeof(T) \* R \* C
这种表示方法是==左结合==的，也称为==行优先==
因此A\[i\]可以理解为第i个行数组，其地址为A + i \* (C * sizeof(T))
故A\[i\]\[j\]地址为A + i \* (C \* sizeof(T)) + j \* sizeof(T)

另一种声明方法：
```cpp
int a[3];
int b[4];
int c[5];
int *univ[3] = {a,b,c};
```
与第一种不同之处在于寻址方式：
A\[i\]\[j\]的内存空间是连续的，因此一般用初始地址(A)+偏移量的方式寻址
如：==A + i \* (C \* sizeof(T)) + j \* sizeof(T)==
而第二种的空间不一定连续，寻址方式为：
- 先用univ作为初始地址，考虑偏移量（系数恒为8而与行数组大小无关）
- 找到对应的行数组的初始地址(a or b or c)，作为新的初始地址再加上偏移量寻址

### 一些汇编代码的实现

固定长度的二维数组：
```cpp
typedef int fix_matrix[16][16];
int fix_ele(fix_matrix a, size_t i, size_t j){
	return a[i][j];
}
```

```s
salq  $6, %rsi                  # 64*i
addq %rsi, %rdi                 # a + 64*i
movl (%rdi, $rdx, 4) %eax       # a + 64*i + 4*j
ret
```

不定长度的二维数组
```cpp
int var_ele(size_t n, int a[n][n], size_t i, size_t j){
	return a[i][j];
}
```

```s
imulq %rdx, %rdi                # n*i
leaq (%rsi, %rdi, 4), %rax      # a + n*i*4
movl (%rax, %rcx, 4), %eax      # a + n*i*4 + j*4
ret
```


## 结构体

### 基本思想
- 为结构体内每个成员分配足够内存空间，然后生成适当的代码指示每个成员的偏移量。
- 偏移量相对于结构体的初始地址

### 汇编代码实现
```cpp
struct rec{
	 int a[4];
	 int i;
	 struct rec* next;
}
void set_val(struct rec* r, int val){
	while(r){
		int i = r->i;
		r->a[i] = val;
		r = r->next;
	}
}
```

```s
.L11:                            # M 代表内存
	movslq 16(%rdi), %rax        # i = M[r + 16]
	movl %esi, (%rdi, %rax, 4)   # M[r + 4*i] = val
	movq 24(%rdi), %rdi          # r = M[r + 24] 之所以是24是因为考虑了数据对齐
	testq %rdi, %rdi             # test r
	jne .L11
```

### 结构体的对齐原则

C 语言中结构体（`struct`）的对齐（Alignment）是编译器为了提高 CPU 访问内存效率而遵循的规则。CPU 访问内存时，通常按固定字节数（如 2、4、8 字节等）“块读取”，若数据未对齐，可能需要多次访问，降低效率。结构体对齐的核心是**让每个成员的地址满足特定对齐要求，且结构体整体大小也满足对齐要求**。

### 一、基本对齐原则（默认规则）

编译器默认的对齐规则可概括为 3 点，以`struct S`为例：

#### 1. 成员的对齐：每个成员的偏移量是其 “自身对齐值” 的整数倍

- **自身对齐值**：成员类型的默认对齐大小（与平台和类型相关）。常见类型的自身对齐值（32 位 / 64 位系统通用，除非特别说明）：
  - `char`：1 字节（对齐值 1）
  - `short`：2 字节（对齐值 2）
  - `int`、`float`：4 字节（对齐值 4）
  - `long long`、`double`：8 字节（对齐值 8）
  - 指针（`*`）：32 位系统 4 字节，64 位系统 8 字节（对齐值同指针大小）
  - 数组：对齐值与数组元素类型的对齐值相同（如`int arr[5]`对齐值为 4）
  - 结构体 / 联合体：对齐值为其内部最大成员的对齐值（见 “嵌套结构体”）。
- **偏移量**：成员相对于结构体首地址的字节距离。若前一个成员的偏移量 + 自身大小 不满足当前成员的对齐值，则会自动填充空白字节（padding），直到偏移量是当前成员对齐值的整数倍。

#### 2. 结构体整体的对齐：总大小是 “最大对齐值” 的整数倍

结构体的总大小（`sizeof(struct S)`）必须是其内部所有成员中**最大对齐值**的整数倍。若按成员大小累加后不满足，会在结构体末尾填充空白字节。

#### 3. 嵌套结构体的对齐：内部结构体作为成员时，按其自身最大对齐值对齐

若结构体`A`中包含结构体`B`，则`B`作为成员的对齐值 = `B`内部最大成员的对齐值，而非`B`的总大小。

### 二、示例解析

通过具体例子理解对齐规则：

#### 示例 1：基础类型成员

```c
struct S1 {
    char a;   // 对齐值1
    int b;    // 对齐值4
    short c;  // 对齐值2
};
```

- 成员`a`：偏移量 0（1 的倍数），占用 0~0 字节。
- 成员`b`：需偏移量为 4 的倍数。前一个成员结束于 0，需填充 3 字节（偏移 1~3），`b`从偏移 4 开始，占用 4~7 字节。
- 成员`c`：需偏移量为 2 的倍数。前一个成员结束于 7，偏移 8 是 2 的倍数，`c`从 8 开始，占用 8~9 字节。
- 总大小：当前累加 10 字节。内部最大对齐值是 4（`int b`），10 不是 4 的倍数，需在末尾填充 2 字节（10~11），最终`sizeof(S1) = 12`。

#### 示例 2：嵌套结构体

```c
struct Sub {
    char x;   // 对齐值1
    double y; // 对齐值8（Sub的最大对齐值为8）
};

struct S2 {
    int a;    // 对齐值4
    struct Sub b; // 对齐值8（Sub的最大对齐值）
    short c;  // 对齐值2
};
```

- 成员`a`：偏移 0~3（4 字节，对齐值 4 满足）。
- 成员`b`（嵌套结构体）：需偏移量为 8 的倍数。前一个结束于 3，填充 4 字节（4~7），`b`从 8 开始：
  - `b.x`占用 8~8，`b.y`需偏移量为 8 的倍数（当前偏移 9，填充 7 字节到 15），`b.y`占用 15~22，因此`b`总占用 8~22（15 字节）。
- 成员`c`：前一个结束于 22，偏移 23 不是 2 的倍数，填充 1 字节到 23，`c`从 24 开始（24 是 2 的倍数），占用 24~25。
- 总大小：当前累加 26 字节。内部最大对齐值是 8（来自`Sub`的`y`），26 不是 8 的倍数，填充 2 字节（26~27），最终`sizeof(S2) = 28`。

### 三、修改对齐方式（#pragma pack）

默认对齐可能导致内存浪费（填充字节多），可通过编译器指令`#pragma pack`强制指定对齐值：

- `#pragma pack(n)`：设置当前对齐值为`n`（`n`为 1、2、4、8 等，需是 2 的幂）。
- `#pragma pack()`：恢复默认对齐。

**规则**：成员的实际对齐值 = `min(自身对齐值, 当前pack值)`，结构体总大小是所有成员实际对齐值的最大值的整数倍。

#### 示例：强制 1 字节对齐（取消对齐）

```c
#pragma pack(1) // 强制按1字节对齐
struct S3 {
    char a;
    int b;
    short c;
};
#pragma pack() // 恢复默认

// 此时无填充字节，sizeof(S3) = 1 + 4 + 2 = 7
```

### 四、关键注意事项

1. **平台相关性**：对齐值与 CPU 架构（32 位 / 64 位）、编译器（GCC、MSVC 等）相关，但基本规则一致。
2. **内存与效率权衡**：默认对齐提高效率但浪费内存，`#pragma pack(1)`节省内存但可能降低访问速度（尤其对`double`等大类型）。
3. **跨平台兼容性**：不同平台默认对齐可能不同，若结构体用于网络传输或文件存储，建议显式指定`#pragma pack`保证一致性。

总结：结构体对齐的核心是 “成员偏移对齐” 和 “整体大小对齐”，通过填充字节满足 CPU 高效访问需求，必要时可通过`#pragma pack`调整。


## 一个经典的汇编实现：链表
- 参考bomblab-phase-6.
## 浮点数
### 寄存器：
- %xmm0，%xmm1，%xmm2······
- 返回值存在%xmm0
- 所有寄存器都是Caller - save
### 指令：
- addss r1 r2 ： r2 += r1(单精度)
- addsd r1 r2 :   r2 += r1(双精度)
### 混合指针和浮点数：
```c
double dincr(double *p, double v){
	double x = *p;
	*p = x + v;
	return x;
}
```

```s
# p in %rdi,  v in %xmm0
movapd %xmm0, %xmm1     # copy v
movsd (%rdi), %xmm0     # x = *p
addsd %xmm0, %xmm1      # t = v + x
movsd %xmm1 (%rdi)      # *p = t
ret                     # return x
```
## 联合体 Union
### 想法：
- Union并不会为每一个成员都分配空间，而是只按照最大的数据分配空间
- 所有数据都存在这个空间内，只不过可以按不同数据类型解释
	- 关键在于**不同的解释不会改动bit**
	- 相当于同一个二进制表示的unsigned解释和int解释
- 与数据类型转换的不同之处：
	- 数据类型转换实际上会改变bit
		- 如：double转化为int时，会舍入精度太高的部分
		- 即强制以不同的方式解释
	- 类比：(-1) >> 1相当于Union，机械的执行右移操作
	- （-1）/ 2 相当于 数据类型转换，会根据实际意义变动
- 这里不同的解释方式一定要考虑**大端序小端序**的区别
### 图例
```c
union {
	unsigned char c[8];
	unsigned short s[4];
	unsigned int i[2];
	unsigned long l[1];
} dw;
```


## 内存

### 内存结构概览

**从顶部往下依次为：**
- 栈：位于整个内存的顶部，栈底地址00007FFFFFFFFFFF（一共47个1）
	- 存储局部变量等
	- 栈是向下增长的，栈最大为8MB
- shared-library：存放库函数的机器代码（相当于可执行文件的代码）
- 堆：可动态分配的内存空间（按需分配）
	- 例如：malloc(), calloc(),new()
	- 堆是向上增长的
- data：静态分配的数据
	- 如：全局变量，静态变量，string constans
- Text：存放可执行程序的指令
	- 是只读的，无法修改(Read-Only)
### 一个内存分配的例子
```c
char big_array[1L<<24];       //data
char huge_array[1L<<24];      //data

int global = 0;

int useless(){return 0;}      //text

int main(){                   //text
	void *p1,*p2,*p3,*p4;
	int local = 0;            //栈
	p1 = malloc(1L << 28);    //堆的高位
	p2 = malloc(1L << 8);     //堆的低位
	/* 动态分配的内存一般都是分低位和高位两块，引用中间的空白区域是非法的 */
	p3 = malloc(1L << 32);    //堆的高位
	p4 = malloc(1L << 8);     //堆的低位
}
```



## 缓冲区溢出（buffer overflow）
### 基本定义：

- 试图访问未被分配的内存


### 最常见形式：

- 在栈中分配了字符数组保存字符串，但字符串过长（称为栈溢出）


### 例子
- 实际上：栈除了echo中声明的8个字节以外，还分配了16个字节（作为缓冲）
	- 当输入的字符超过24个之后，就会污染调用该函数的返回地址（%rsp + 24）
	- 超过32个之后，更是会污染caller中保存的状态
- 相似的函数除了gets（），还有
	- strcpy，strcat，scanf，fscanf，sscanf（when input %s）
- 代码注入攻击：
	- 如果在字符串内包含一些可执行代码的字节编码，并用指向攻击代码的指针覆盖返回地址
	- 那么ret的效果就会是跳转到攻击代码


### 对抗缓冲区溢出攻击
- 使用安全的接口比如fgets（），strncpy（）
	- fgets（buf，8， stdin）；限制了最大的输入字符数为8
	- use %ns when scanf（）
- **栈随机化**
	- 为了防止攻击者成功预测返回地址在栈中存放的位置，将栈随机化
	- 比如在程序开始时，在栈上分配一段0~n字节之间的随即大小的空间
		- 程序不使用这段空间，但使得程序每次执行时后续栈位置发生了变化
- **标记栈和堆区域的代码是不可执行的**
- **栈破坏检测**
	- 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的**金丝雀值（or哨兵值）**
		- 金丝雀值存在缓冲区刚开始的地方，因此一旦有任何溢出必然会改变。
		- 金丝雀值的低位一般是0（可以接受比给定长度多1，因为\0刚好是0）
	- 在恢复寄存器状态和函数返回前，检测该值是否改变
		- 如果改变，程序异常终止
	- 最近的GCC版本会考察一个函数是否容易遭受栈溢出攻击，并且自动插入该检测

 
### 其他的攻击手段
   
- 采用现成的代码：如library code from stdlib
	- 只需要找到其在lib中存放的地址，然后设法让%rip等于地址，即可执行
	- 将多段代码(gadgets)串在一起以实现预期的效果
- 关键：ret（弹出栈，并将其放入%rip）
	- ret可以实现指令的跳转
	- 如果跳转的lib指令中刚好又有ret，则可继续跳转
	- 被称为**面向返回编程**

### 什么是面向返回编程？

**面向返回编程**，也称为**ROP**，是一种高级的内存攻击技术。攻击者利用它来绕过现代操作系统的安全保护措施，如 **DEP** 和 **NX位**。

- **目标**：在存在安全防护的情况下，执行攻击者指定的恶意代码。
    
- **核心思想**：不复用完整的代码，也不注入新的恶意代码，而是**复用目标程序或系统库中已有的代码片段**。
    
- **基础**：它是对 **Ret2libc** 攻击技术的一种泛化和增强。
    

### 为什么需要ROP？——背景：DEP/NX保护

在早期，缓冲区溢出攻击非常简单：攻击者将恶意代码写入栈或堆，然后通过溢出覆盖返回地址，让程序跳转到恶意代码处执行。

为了防御这种攻击，现代操作系统引入了 **数据执行保护** 或 **NX位** 技术。它可以将内存页标记为**“可读”或“可写”，但不能“可执行”**。这意味着，即使攻击者成功将恶意代码注入到栈或堆中，当程序跳转到该处尝试执行时，CPU会抛出异常并终止程序，因为那块内存不允许执行代码。

ROP就是为了绕过这项保护而诞生的。

### ROP的核心原理

既然不能执行自己注入的代码，那就**“借刀杀人”**，执行程序本身自带的代码。

1. **“小工具”**：
    
    - 攻击者在现有的、合法的程序或库中，寻找以 **`ret`** 指令结尾的、短小的指令序列。这些序列被称为 **Gadgets**。
        
    - 例如，一个 Gadget 可能是：`pop eax; ret` 或 `mov [edx], eax; ret`。
        
    - 每个 Gadget 完成一个非常微小的操作。
        
2. **链式调用**：
    
    - 攻击者通过缓冲区溢出等技术，在栈上精心布置一个 **ROP Chain**。
        
    - 这个链由一系列 **Gadget 的地址** 和 **这些Gadget所需的数据** 组成。
        
    - 当第一个 Gadget 执行完毕后，它的 `ret` 指令会从栈上弹出下一个地址，并跳转到那个地址执行，也就是**下一个 Gadget**。如此反复，形成一个 Gadget 的执行链。
        

### ROP攻击的步骤

1. **信息收集**：确定目标程序和其使用的库，找到其中所有可用的 Gadgets。
    
2. **构建ROP链**：根据想要实现的功能，将多个 Gadgets 像拼乐高积木一样组合起来。例如，可以通过一系列 Gadgets 来调用 `system(“/bin/sh”)`，从而获得一个系统 shell。
    
3. **触发漏洞**：利用栈溢出等漏洞，覆盖函数的返回地址，使其指向 ROP Chain 的第一个 Gadget。
    
4. **链式执行**：CPU 开始执行第一个 Gadget -> `ret` -> 第二个 Gadget -> `ret` -> ... 直到完成整个攻击逻辑。
    

### 一个简化的示例

假设我们想调用 `system(“/bin/sh”)`。我们需要：

1. 将字符串 “/bin/sh” 的地址放入 `rdi` 寄存器。
    
2. 跳转到 `system` 函数的地址。
    

对应的 ROP Chain 在栈上可能这样布局：

<地址1： pop rdi; ret 这个Gadget>
<地址2： 指向字符串 "/bin/sh" 的指针>
<地址3： system函数的地址>

执行流程：

1. 返回地址被覆盖为 `pop rdi; ret`，CPU 跳转执行。

2. `pop rdi` 从栈上弹出下一个值，也就是 “/bin/sh” 的地址，存入 `rdi` 寄存器。

3. 执行 `ret`，从栈上弹出下一个值，也就是 `system` 的地址，并跳转过去。

4. `system` 函数开始执行，它发现 `rdi` 寄存器里是 “/bin/sh”，于是执行该命令，启动一个 shell。

### 执行流程分解

假设栈的初始状态如下（从高地址到低地址）：

text

rsp -> [值A]        (8字节)
       [值B/地址X]  (8字节) 
       [其他数据...]

1. **执行 `pop rdi`**：
    
    - 将 `rsp` 当前指向的 **8字节数据（值A）** 弹出到 `rdi` 寄存器中
        
    - 同时栈指针 **`rsp = rsp + 8`**，现在指向下一个栈单元
        
2. **栈状态变化**：
    
    text
    
    rdi = 值A
    rsp -> [值B/地址X]  (8字节)
           [其他数据...]
    
3. **执行 `ret`**：
    
    - `ret` 指令相当于 `pop rip`
        
    - 将 `rsp` 当前指向的 **8字节数据（值B/地址X）** 弹出到指令指针 `rip` 中
        
    - 同时栈指针 **`rsp = rsp + 8`**
        
    - CPU 开始执行地址X处的代码
        

### 在ROP链中的实际应用

在真实的ROP攻击中，栈布局会是这样的：

text

rsp -> [gadget地址: pop rdi; ret]  ← 初始返回地址指向这里
       [参数值: "/bin/sh"的地址]    ← 被pop到rdi
       [下一个gadget地址: system]   ← 被ret跳转过去 执行 system("/bin/sh")，启动一个 Shell
       [更多gadget...]

### 防御ROP的技术

ROP并非无法防御，常见的防御措施包括：

- **ASLR**：地址空间布局随机化。每次程序启动时，系统和库的基地址都会变化，使得攻击者难以确定 Gadgets 的具体地址。
    
- **Stack Canaries**：在栈上的返回地址之前放置一个随机值，在函数返回前检查该值是否被修改，若被修改则终止程序。
    
- **控制流完整性**：一种更先进的技术，通过编译时或运行时的检查，确保程序执行流不会偏离预定的合法路径。
    
- **减少可用Gadgets**：使用特殊的编译选项，减少代码中以 `ret` 结尾的指令序列。
 