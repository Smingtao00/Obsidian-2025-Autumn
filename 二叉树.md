#二叉树 

1. [[二叉搜索树]]
2. [[堆与优先队列]]
3. [[Huffman编码]]
4. [[平衡树]]
### 概念

- 满二叉树：如果一棵二叉树的节点，或为树叶（0度节点），或为两棵非空子树（2度节点），则称为==满二叉树==

- 完全二叉树：

  - 最多只有最下面的两层节点度数可以小于2
  - 最下面一层的节点都集中在该层最左边、连续位置上
  - ==路径长度最短==：由根结点到各个结点的路径长度总和在具有同样结点数的二叉树中最小，任意一棵二叉树中根结点到各结点的最长路径一定不短于结点数目相同的完全二叉树 中的路径长度

- 扩充二叉树：当二叉树节点出现空指针时，就增加一个特殊结点——空树叶

  - 度为1的结点，在它下面增加1个空树叶
  - 度为0的树叶，在它下面增加2个空树叶

  扩充的二叉树是满二叉树，新增加空树叶(外部结点L)的个数 $N_0$ 等于原来二叉树结点个数(内部结点 $N_2$ ) 加1（==$N_0 = N_2 + 1$==）

  - 外部路径长度E：从扩充二叉树的根到每个外部结点的路径长度之和
  - 内部路径长度I：从扩充二叉树的根每个内部结点的路径长度之和

  $E = I + 2n$：其中 $n$ 是内部节点的个数

### 基本性质

- 在非空二叉树的第 $i$ 层上至多有 $2^i$ 个节点（$i\geq 0$）
- 深度为 $k$ 的二叉树中最多有 $2^{k + 1} - 1$ 个节点 （$k\geq 0$）
- 懒得打了，直接看吧 ()
- [[第5章二叉树.pdf#page=16&selection=19,2,29,2|第5章二叉树, 页面 16]]

### 代码写法

#### 二叉堆

```c++ {.line-numbers}
#include <queue>
#include <vector>
priority_queue<int, vector<int>, less<int>> a; //大根堆
priority_queue<int, vector<int>, great<int>> b; //小根堆
```

二叉树

C风格:

```c++ {.line-numbers}
int parent[N]
int lc[N], rch[N]
// -- or --
int child[N][2]
```

树上遍历

```c++ {.line-numbers}
void preorder(BiTree* root) {
    if (root) {
		cout << root->key << " ";
        preorder(root->left);
        preorder(root->right);
    }
}
```

